# 4. プロトコルスタックの移植

プラットフォーム依存のコードを追加しながら、自作プロトコルスタックを1モジュールづつ移植していきます。

なお、全てのモジュールに共通して下記の修正を加えてあります。

+ システムヘッダのインクルード（`#include <>`）を削除
    + `-nostdinc`への対応
    + 替わりに`platform.h`を冒頭でインクルード
+ ローカル変数の大きなバッファを動的メモリ確保に変更
    + 主に送信パケット構築用のバッファ
    + スタックが溢れてクラッシュしてしまう問題への対処
    + 本来はmbufのような仕組みを採用すべきだが複雑になってしまうので見送り

プロトコルスタック本体のコードは移植しやすい作りにしていることもあり、上記以外に目立った変更はありません。

## 4.1. メインモジュール

自作プロトコルスタックのメインモジュールを移植します。

#### ✅ 暫定コードの削除

ここまで暫定的に作成していた`net/net.c`を削除します。

```
$ rm net/net.c
```

#### ✅ メインモジュールのコードの追加

メインモジュールのコードを追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/net.h</span></summary>

```c
#ifndef NET_H
#define NET_H

#include "platform.h"

#ifndef IFNAMSIZ
#define IFNAMSIZ 16
#endif

#define NET_DEVICE_TYPE_DUMMY     0x0000
#define NET_DEVICE_TYPE_LOOPBACK  0x0001
#define NET_DEVICE_TYPE_ETHERNET  0x0002

#define NET_DEVICE_FLAG_UP        0x0001
#define NET_DEVICE_FLAG_LOOPBACK  0x0010
#define NET_DEVICE_FLAG_BROADCAST 0x0020
#define NET_DEVICE_FLAG_P2P       0x0040
#define NET_DEVICE_FLAG_NEED_ARP  0x0100

#define NET_DEVICE_ADDR_LEN 16

#define NET_DEVICE_IS_UP(x) ((x)->flags & NET_DEVICE_FLAG_UP)
#define NET_DEVICE_STATE(x) (NET_DEVICE_IS_UP(x) ? "up" : "down")

/* NOTE: use same value as the Ethernet types */
#define NET_PROTOCOL_TYPE_IP   0x0800
#define NET_PROTOCOL_TYPE_ARP  0x0806
#define NTT_PROTOCOL_TYPE_IPV6 0x86dd

#define NET_IFACE_FAMILY_IP    1
#define NET_IFACE_FAMILY_IPV6  2

#define NET_IFACE(x) ((struct net_iface *)(x))

struct net_device {
    struct net_device *next;
    struct net_iface *ifaces; /* NOTE: if you want to add/delete the entries after net_run(), you need to protect ifaces with a mutex. */
    unsigned int index;
    char name[IFNAMSIZ];
    uint16_t type;
    uint16_t mtu;
    uint16_t flags;
    uint16_t hlen; /* header length */
    uint16_t alen; /* address length */
    uint8_t addr[NET_DEVICE_ADDR_LEN];
    union {
        uint8_t peer[NET_DEVICE_ADDR_LEN];
        uint8_t broadcast[NET_DEVICE_ADDR_LEN];
    };
    struct net_device_ops *ops;
    void *priv;
};

struct net_device_ops {
    int (*open)(struct net_device *dev);
    int (*close)(struct net_device *dev);
    int (*transmit)(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst);
};

struct net_iface {
    struct net_iface *next;
    struct net_device *dev; /* back pointer to parent */
    int family;
    /* depends on implementation of protocols. */
};

extern struct net_device *
net_device_alloc(void);
extern int
net_device_register(struct net_device *dev);
extern int
net_device_add_iface(struct net_device *dev, struct net_iface *iface);
extern struct net_iface *
net_device_get_iface(struct net_device *dev, int family);
extern int
net_device_output(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst);

extern int
net_protocol_register(uint16_t type, void (*handler)(const uint8_t *data, size_t len, struct net_device *dev));

extern int
net_timer_register(struct timeval interval, void (*handler)(void));
extern int
net_timer_handler(void);

extern int
net_input_handler(uint16_t type, const uint8_t *data, size_t len, struct net_device *dev);
extern int
net_softirq_handler(void);

extern int
net_event_subscribe(void (*handler)(void *arg), void *arg);
extern int
net_event_handler(void);
extern void
net_raise_event(void);

extern int
net_run(void);
extern void
net_shutdown(void);
extern int
net_init(void);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/net.c</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "net.h"

struct net_protocol {
    struct net_protocol *next;
    uint16_t type;
    struct queue_head queue; /* input queue */
    void (*handler)(const uint8_t *data, size_t len, struct net_device *dev);
};

struct net_protocol_queue_entry {
    struct net_device *dev;
    size_t len;
    uint8_t data[];
};

struct net_timer {
    struct net_timer *next;
    struct timeval interval;
    struct timeval last;
    void (*handler)(void);
};

struct net_event {
    struct net_event *next;
    void (*handler)(void *arg);
    void *arg;
};

/* NOTE: if you want to add/delete the entries after net_run(), you need to protect these lists with a mutex. */
static struct net_device *devices;
static struct net_protocol *protocols;
static struct net_timer *timers;
static struct net_event *events;

struct net_device *
net_device_alloc(void)
{
    struct net_device *dev;

    dev = memory_alloc(sizeof(*dev));
    if (!dev) {
        errorf("memory_alloc() failure");
        return NULL;
    }
    return dev;
}

/* NOTE: must not be call after net_run() */
int
net_device_register(struct net_device *dev)
{
    static unsigned int index = 0;

    dev->index = index++;
    snprintf(dev->name, sizeof(dev->name), "net%d", dev->index);
    dev->next = devices;
    devices = dev;
    infof("registered, dev=%s, type=0x%04x", dev->name, dev->type);
    return 0;
}

static int
net_device_open(struct net_device *dev)
{
    if (NET_DEVICE_IS_UP(dev)) {
        errorf("already opened, dev=%s", dev->name);
        return -1;
    }
    if (dev->ops->open) {
        if (dev->ops->open(dev) == -1) {
            errorf("failure, dev=%s", dev->name);
            return -1;
        }
    }
    dev->flags |= NET_DEVICE_FLAG_UP;
    infof("dev=%s, state=%s", dev->name, NET_DEVICE_STATE(dev));
    return 0;
}

static int
net_device_close(struct net_device *dev)
{
    if (!NET_DEVICE_IS_UP(dev)) {
        errorf("not opened, dev=%s", dev->name);
        return -1;
    }
    if (dev->ops->close) {
        if (dev->ops->close(dev) == -1) {
            errorf("failure, dev=%s", dev->name);
            return -1;
        }
    }
    dev->flags &= ~NET_DEVICE_FLAG_UP;
    infof("dev=%s, state=%s", dev->name, NET_DEVICE_STATE(dev));
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_device_add_iface(struct net_device *dev, struct net_iface *iface)
{
    struct net_iface *entry;

    for (entry = dev->ifaces; entry; entry = entry->next) {
        if (entry->family == iface->family) {
            /* NOTE: For simplicity, only one iface can be added per family. */
            errorf("already exists, dev=%s, family=%d", dev->name, entry->family);
            return -1;
        }
    }
    iface->next = dev->ifaces;
    iface->dev = dev;
    dev->ifaces = iface;
    return 0;
}

struct net_iface *
net_device_get_iface(struct net_device *dev, int family)
{
    struct net_iface *entry;

    for (entry = dev->ifaces; entry; entry = entry->next) {
        if (entry->family == family) {
            break;
        }
    }
    return entry;
}

int
net_device_output(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst)
{
    if (!NET_DEVICE_IS_UP(dev)) {
        errorf("not opened, dev=%s", dev->name);
        return -1;
    }
    if (len > dev->mtu) {
        errorf("too long, dev=%s, mtu=%u, len=%zu", dev->name, dev->mtu, len);
        return -1;
    }
    debugf("dev=%s, type=0x%04x, len=%zu", dev->name, type, len);
    debugdump(data, len);
    if (dev->ops->transmit(dev, type, data, len, dst) == -1) {
        errorf("device transmit failure, dev=%s, len=%zu", dev->name, len);
        return -1;
    }
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_protocol_register(uint16_t type, void (*handler)(const uint8_t *data, size_t len, struct net_device *dev))
{
    struct net_protocol *proto;

    for (proto = protocols; proto; proto = proto->next) {
        if (type == proto->type) {
            errorf("already registered, type=0x%04x", type);
            return -1;
        }
    }
    proto = memory_alloc(sizeof(*proto));
    if (!proto) {
        errorf("memory_alloc() failure");
        return -1;
    }
    proto->type = type;
    proto->handler = handler;
    proto->next = protocols;
    protocols = proto;
    infof("registered, type=0x%04x", type);
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_timer_register(struct timeval interval, void (*handler)(void))
{
    struct net_timer *timer;

    timer = memory_alloc(sizeof(*timer));
    if (!timer) {
        errorf("memory_alloc() failure");
        return -1;
    }
    timer->interval = interval;
    gettimeofday(&timer->last, NULL);
    timer->handler = handler;
    timer->next = timers;
    timers = timer;
    infof("registered: interval={%d, %d}", interval.tv_sec, interval.tv_usec);
    return 0;
}

int
net_timer_handler(void)
{
    struct net_timer *timer;
    struct timeval now, diff;

    for (timer = timers; timer; timer = timer->next) {
        gettimeofday(&now, NULL);
        timersub(&now, &timer->last, &diff);
        if (timercmp(&timer->interval, &diff, <) != 0) { /* true (!0) or false (0) */
            timer->handler();
            timer->last = now;
        }
    }
    return 0;
}

int
net_input_handler(uint16_t type, const uint8_t *data, size_t len, struct net_device *dev)
{
    struct net_protocol *proto;
    struct net_protocol_queue_entry *entry;

    for (proto = protocols; proto; proto = proto->next) {
        if (proto->type == type) {
            entry = memory_alloc(sizeof(*entry) + len);
            if (!entry) {
                errorf("memory_alloc() failure");
                return -1;
            }
            entry->dev = dev;
            entry->len = len;
            memcpy(entry->data, data, len);
            if (!queue_push(&proto->queue, entry)) {
                errorf("queue_push() failure");
                memory_free(entry);
                return -1;
            }
            debugf("queue pushed (num:%u), dev=%s, type=0x%04x, len=%zu", proto->queue.num, dev->name, type, len);
            debugdump(data, len);
            intr_raise_irq(INTR_IRQ_SOFTIRQ);
            return 0;
        }
    }
    /* unsupported protocol */
    return 0;
}

int
net_softirq_handler(void)
{
    struct net_protocol *proto;
    struct net_protocol_queue_entry *entry;

    for (proto = protocols; proto; proto = proto->next) {
        while (1) {
            entry = queue_pop(&proto->queue);
            if (!entry) {
                break;
            }
            debugf("queue popped (num:%u), dev=%s, type=0x%04x, len=%zu", proto->queue.num, entry->dev->name, proto->type, entry->len);
            debugdump(entry->data, entry->len);
            proto->handler(entry->data, entry->len, entry->dev);
            memory_free(entry);
        }
    }
    return 0;
}

/* NOTE: must not be call after net_run() */
int
net_event_subscribe(void (*handler)(void *arg), void *arg)
{
    struct net_event *event;

    event = memory_alloc(sizeof(*event));
    if (!event) {
        errorf("memory_alloc() failure");
        return -1;
    }
    event->handler = handler;
    event->arg = arg;
    event->next = events;
    events = event;
    return 0;
}

int
net_event_handler(void)
{
    struct net_event *event;

    for (event = events; event; event = event->next) {
        event->handler(event->arg);
    }
    return 0;
}

void
net_raise_event()
{
    intr_raise_irq(INTR_IRQ_EVENT);
}

int
net_run(void)
{
    struct net_device *dev;

    if (intr_run() == -1) {
        errorf("intr_run() failure");
        return -1;
    }
    debugf("open all devices...");
    for (dev = devices; dev; dev = dev->next) {
        net_device_open(dev);
    }
    debugf("running...");
    return 0;
}

void
net_shutdown(void)
{
    struct net_device *dev;

    debugf("close all devices...");
    for (dev = devices; dev; dev = dev->next) {
        net_device_close(dev);
    }
    intr_shutdown();
    debugf("shutting down");
}

int
net_init(void)
{
    if (intr_init() == -1) {
        errorf("intr_init() failure");
        return -1;
    }
    infof("initialized");
    return 0;
}

void
netinit(void)
{
    if (net_init() == -1) {
        panic("net_init() failure");
    }
}

void
netrun(void)
{
    if (net_run() == -1) {
        panic("net_run() failure");
    }
}
```
</details>

1モジュールづつ移植していく都合上、`net_init()`で行っていた各モジュールの初期化処理を一旦削除しています。また、xv6から呼び出すための`netinit()`と`netrun()`を追加していますが、どちらも`net_init()`と`net_run()`に対するラッパー関数です。

#### ✅ vprintfmt() の修正

自作プロトコルスタックのコードでは、`size_t`や`ssize_t`の値をログ出力するためにフォーマット文字列に`%zd`および`%zu`を使用していますが、フォーマット文字列の解析関数（`vprintfmt()`）が、長さ修飾子「`z`」に対応していません。ここでは、フォーマット文字列の解析関数に対し、長さ修飾子`z`を無視する変更を加えます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">printfmt.c</span></summary>

```diff
...

 void
 vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
 {
...
     // escaped '%' character
     case '%':
       putch(ch, putdat);
       break;

+    case 'z':
+      goto reswitch;
+
     // unrecognized escape sequence - just print it literally
     default:
       putch('%', putdat);
       for (fmt--; fmt[-1] != '%'; fmt--)
         /* do nothing */;
       break;
     }
   }
 }

...
```
</details>

#### ✅ 割り込みの対応

オリジナル版では割り込みを再現するための仕組みを動かすために`intr_init()`,`intr_run()`,`intr_shutdown()`を用意していましたが、必要ないので空にしておきます。任意の割り込みを発生させる`intr_raise_irq()`は、インラインアセンブラで`int`命令を発行するようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/plartform.h</span></summary>

```diff
...

 /*
  * Interrupt
  */

 #include "traps.h"

+#define INTR_IRQ_SOFTIRQ T_SOFT
+#define INTR_IRQ_EVENT T_EVENT
+
+static inline int
+intr_raise_irq(unsigned int irq)
+{
+    asm volatile("int %0" : : "i" (irq));
+    return 0;
+}
+
+static inline int
+intr_init(void)
+{
+    return 0;
+}
+
+static inline int
+intr_run(void)
+{
+    return 0;
+}
+
+static inline void
+intr_shutdown(void)
+{
+    return;
+}

...
```
</details>

ソフトウェア割り込みとイベント通知用の割り込みには、それぞれ`T_SOFT`と`T_EVENT`を割り当てます。これらの実際の値は`traps.h`に追加します。割り込み番号は空いていそうなものを適当に選択しています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">traps.h</span></summary>

```diff
...

 // These are arbitrarily chosen, but with care not to overlap
 // processor defined exceptions or interrupt vectors.
 #define T_SYSCALL       64      // system call
+#define T_SOFT          65      // softirq
+#define T_EVENT         66      // event
 #define T_DEFAULT      500      // catchall

...
```
</details>

これらの割り込みを捕捉した際の処理を`trap.c`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">trap.c</span></summary>

```diff
...

 void
 trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
     if(myproc()->killed)
       exit();
     myproc()->tf = tf;
     syscall();
     if(myproc()->killed)
       exit();
     return;
   }
+  if(tf->trapno == T_SOFT){
+    net_softirq_handler();
+    return;
+  }
+  if(tf->trapno == T_EVENT){
+    net_event_handler();
+    return;
+  }

...
 }
```
</details>

#### ✅ プロトタイプ宣言の追加

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">defs.h</span></summary>

```diff
...

 // net/net.c
 void            netinit(void);
+void            netrun(void);
+int             net_softirq_handler(void);
+int             net_event_handler(void);

...
```
</details>

#### ✅ プロトコルスタックの起動

PCIの初期化が終わった後にプロトコルスタックを起動するようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">main.c</span></summary>

```diff
...

 int
 main(void)
 {
   kinit1(end, P2V(4*1024*1024)); // phys page allocator
   kvmalloc();      // kernel page table
   mpinit();        // detect other processors
   lapicinit();     // interrupt controller
   seginit();       // segment descriptors
   picinit();       // disable pic
   ioapicinit();    // another interrupt controller
   consoleinit();   // console hardware
   uartinit();      // serial port
   pinit();         // process table
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
   ideinit();       // disk 
   netinit();       // network stack
   pciinit();       // pci devices
+  netrun();        // start networking
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
   mpmain();        // finish this processor's setup
 }

...
```
</details>

#### ✅ デバイスドライバの修正

自作プロトコルスタックのデバイスとドライバの仕組みに適合するようにe1000ドライバを修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/driver/e1000.c</span></summary>

```diff
 #include "platform.h"

 #include "param.h"
 #include "proc.h"
 #include "memlayout.h"
 #include "pci.h"

 #include "util.h"
+#include "net.h"

 #include "e1000_dev.h"

+#define PRIV(x) ((struct e1000 *)(x)->priv)

 #define RX_RING_SIZE 16
 #define TX_RING_SIZE 16

 struct e1000 {
     struct e1000 *next;
+    struct net_device *dev;
     uint32_t mmio_base;
     struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));;
     struct tx_desc tx_ring[TX_RING_SIZE] __attribute__((aligned(16)));;
     uint8_t irq;
 };

 static int
-e1000_open(struct e1000 *e1000)
+e1000_open(struct net_device *dev)
 {
+    struct e1000 *e1000;
+
+    e1000 = PRIV(dev);
     // enable interrupts
     e1000_reg_write(e1000, E1000_IMS, E1000_IMS_RXT0);
     // clear existing pending interrupts
     e1000_reg_read(e1000, E1000_ICR);
     // enable RX/TX
     e1000_reg_write(e1000, E1000_RCTL, e1000_reg_read(e1000, E1000_RCTL) | E1000_RCTL_EN);
     e1000_reg_write(e1000, E1000_TCTL, e1000_reg_read(e1000, E1000_TCTL) | E1000_TCTL_EN);
     // link up
     e1000_reg_write(e1000, E1000_CTL, e1000_reg_read(e1000, E1000_CTL) | E1000_CTL_SLU);
     return 0;
 }

+static int
+e1000_close(struct net_device *dev)
+{
+    struct e1000 *e1000;
+
+    e1000 = PRIV(dev);
+    // disable interrupts
+    e1000_reg_write(e1000, E1000_IMC, E1000_IMS_RXT0);
+    // clear existing pending interrupts
+    e1000_reg_read(e1000, E1000_ICR);
+    // disable RX/TX
+    e1000_reg_write(e1000, E1000_RCTL, e1000_reg_read(e1000, E1000_RCTL) & ~E1000_RCTL_EN);
+    e1000_reg_write(e1000, E1000_TCTL, e1000_reg_read(e1000, E1000_TCTL) & ~E1000_TCTL_EN);
+    // link down
+    e1000_reg_write(e1000, E1000_CTL, e1000_reg_read(e1000, E1000_CTL) & ~E1000_CTL_SLU);
+    return 0;
+}
+
+static ssize_t
+e1000_transmit(struct net_device *dev, uint16_t type, const uint8_t *packet, size_t len, const void *dst)
+{
+    return 0;
+}
+

 void
 e1000intr(void)
 {
...
 }

+struct net_device_ops e1000_ops = {
+    .open = e1000_open,
+    .close = e1000_close,
+    .transmit = e1000_transmit,
+};
+

 int
 e1000init(struct pci_func *pcif)
 {
     struct e1000 *e1000;
     uint8_t addr[6];
+    struct net_device *dev;
 
     e1000 = (struct e1000 *)memory_alloc(sizeof(*e1000));
     if (!e1000) {
         errorf("memory_alloc() failure");
         return -1;
     }
     pci_func_enable(pcif);
     e1000->mmio_base = e1000_resolve_mmio_base(pcif);
     e1000_read_addr_from_eeprom(e1000, addr);
     debugf("addr: %02x:%02x:%02x:%02x:%02x:%02x",
         addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
     for (int n = 0; n < 128; n++)
         e1000_reg_write(e1000, E1000_MTA + (n << 2), 0);
     e1000_rx_init(e1000);
     e1000_tx_init(e1000);
     e1000->irq = pcif->irq_line;
+    dev = net_device_alloc();
+    if (!dev) {
+        errorf("net_device_alloc() failure");
+        memory_free(e1000);
+        return -1;
+    }
+    memcpy(dev->addr, addr, sizeof(addr));
+    dev->priv = e1000;
+    dev->ops = &e1000_ops;
+    if (net_device_register(dev) == -1) {
+        errorf("nt_device_register() failure");
+        memory_free(dev);
+        memory_free(e1000);
+        return -1;
+    }
+    e1000->dev = dev;
     e1000->next = devices;
     devices = e1000;
     ioapicenable(e1000->irq, ncpu - 1);
-    e1000_open(e1000);
     infof("initialized, irq=%d", e1000->irq);
     return 0;
 }
```
</details>

#### ✅ 動作確認

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
12:17:05.000 [I] net_init: initialized (net/net.c:339)
PCI: 00:00.0: 8086:1237: class: 6.0 (Bridge device) irq: 0
PCI: 00:01.0: 8086:7000: class: 6.1 (Bridge device) irq: 0
PCI: 00:01.1: 8086:7010: class: 1.1 (Storage controller) irq: 0
PCI: 00:01.3: 8086:7113: class: 6.80 (Bridge device) irq: 9
PCI: 00:02.0: 1234:1111: class: 3.0 (Display controller) irq: 0
PCI: 00:03.0: 8086:100e: class: 2.0 (Network controller) irq: 11
PCI function 00:03.0 (8086:100e) enabled
12:17:05.000 [D] e1000init: addr: 52:54:00:12:34:56 (net/platform/xv6/driver/e1000.c:240)
12:17:05.000 [I] net_device_register: registered, dev=net0, type=0x0000 (net/net.c:61)
12:17:05.000 [I] e1000init: initialized, irq=11 (net/platform/xv6/driver/e1000.c:266)
12:17:05.000 [D] net_run: open all devices... (net/net.c:311)
12:17:05.000 [I] net_device_open: dev=net0, state=up (net/net.c:79)
12:17:05.000 [D] net_run: running... (net/net.c:315)
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
...
```
</details>

## 4.2. Ethernetモジュール

自作プロトコルスタックのEthernetモジュールを移植します。

#### ✅ Ethernetモジュールのコードの追加

Ethernetモジュールのコードを追加します。送受信ともにローカル変数で持っていた大きなバッファを動的メモリ確保に変更してあります。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/ether.h</span></summary>

```c
#ifndef ETHER_H
#define ETHER_H

#include "platform.h"

#include "net.h"

#define ETHER_ADDR_LEN 6
#define ETHER_ADDR_STR_LEN 18 /* "xx:xx:xx:xx:xx:xx\0" */

#define ETHER_HDR_SIZE 14
#define ETHER_FRAME_SIZE_MIN   60 /* without FCS */
#define ETHER_FRAME_SIZE_MAX 1514 /* without FCS */
#define ETHER_PAYLOAD_SIZE_MIN (ETHER_FRAME_SIZE_MIN - ETHER_HDR_SIZE)
#define ETHER_PAYLOAD_SIZE_MAX (ETHER_FRAME_SIZE_MAX - ETHER_HDR_SIZE)

/* see https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.txt */
#define ETHER_TYPE_IP   0x0800
#define ETHER_TYPE_ARP  0x0806
#define ETHER_TYPE_IPV6 0x86dd

extern const uint8_t ETHER_ADDR_ANY[ETHER_ADDR_LEN];
extern const uint8_t ETHER_ADDR_BROADCAST[ETHER_ADDR_LEN];

extern int
ether_addr_pton(const char *p, uint8_t *n);
extern char *
ether_addr_ntop(const uint8_t *n, char *p, size_t size);

typedef ssize_t (*ether_transmit_func_t)(struct net_device *dev, const uint8_t *data, size_t len);
typedef ssize_t (*ether_input_func_t)(struct net_device *dev, uint8_t *buf, size_t size);

extern int
ether_transmit_helper(struct net_device *dev, uint16_t type, const uint8_t *payload, size_t plen, const void *dst, ether_transmit_func_t callback);
extern int
ether_input_helper(struct net_device *dev, ether_input_func_t callback);
extern void
ether_setup_helper(struct net_device *dev);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/ether.c</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "net.h"
#include "ether.h"

struct ether_hdr {
    uint8_t dst[ETHER_ADDR_LEN];
    uint8_t src[ETHER_ADDR_LEN];
    uint16_t type;
};

const uint8_t ETHER_ADDR_ANY[ETHER_ADDR_LEN] = {"\x00\x00\x00\x00\x00\x00"};
const uint8_t ETHER_ADDR_BROADCAST[ETHER_ADDR_LEN] = {"\xff\xff\xff\xff\xff\xff"};

int
ether_addr_pton(const char *p, uint8_t *n)
{
    int index;
    char *ep;
    long val;

    if (!p || !n) {
        return -1;
    }
    for (index = 0; index < ETHER_ADDR_LEN; index++) {
        val = strtol(p, &ep, 16);
        if (ep == p || val < 0 || val > 0xff || (index < ETHER_ADDR_LEN - 1 && *ep != ':')) {
            break;
        }
        n[index] = (uint8_t)val;
        p = ep + 1;
    }
    if (index != ETHER_ADDR_LEN || *ep != '\0') {
        return -1;
    }
    return 0;
}

char *
ether_addr_ntop(const uint8_t *n, char *p, size_t size)
{
    if (!n || !p) {
        return NULL;
    }
    snprintf(p, size, "%02x:%02x:%02x:%02x:%02x:%02x", n[0], n[1], n[2], n[3], n[4], n[5]);
    return p;
}

static void
ether_dump(const uint8_t *frame, size_t flen)
{
    struct ether_hdr *hdr;
    char addr[ETHER_ADDR_STR_LEN];

    hdr = (struct ether_hdr *)frame;
    flockfile(stderr);
    fprintf(stderr, "        src: %s\n", ether_addr_ntop(hdr->src, addr, sizeof(addr)));
    fprintf(stderr, "        dst: %s\n", ether_addr_ntop(hdr->dst, addr, sizeof(addr)));
    fprintf(stderr, "       type: 0x%04x\n", ntoh16(hdr->type));
#ifdef HEXDUMP
    hexdump(stderr, frame, flen);
#endif
    funlockfile(stderr);
}

int
ether_transmit_helper(struct net_device *dev, uint16_t type, const uint8_t *data, size_t len, const void *dst, ether_transmit_func_t callback)
{
    uint8_t *frame;
    struct ether_hdr *hdr;
    size_t flen, pad = 0;
    int ret;

    frame = memory_alloc(ETHER_FRAME_SIZE_MAX);
    if (!frame) {
        return -1;
    }
    hdr = (struct ether_hdr *)frame;
    memcpy(hdr->dst, dst, ETHER_ADDR_LEN);
    memcpy(hdr->src, dev->addr, ETHER_ADDR_LEN);
    hdr->type = hton16(type);
    memcpy(hdr+1, data, len);
    if (len < ETHER_PAYLOAD_SIZE_MIN) {
        pad = ETHER_PAYLOAD_SIZE_MIN - len;
    }
    flen = sizeof(*hdr) + len + pad;
    debugf("dev=%s, type=0x%04x, len=%zu", dev->name, type, flen);
    ether_dump(frame, flen);
    ret = callback(dev, frame, flen) == (ssize_t)flen ? 0 : -1;
    memory_free(frame);
    return ret;
}

int
ether_input_helper(struct net_device *dev, ether_input_func_t callback)
{
    uint8_t *frame;
    ssize_t flen;
    struct ether_hdr *hdr;
    uint16_t type;
    int ret;

    frame = memory_alloc(ETHER_FRAME_SIZE_MAX);
    if (!frame) {
        return -1;
    }
    flen = callback(dev, frame, ETHER_FRAME_SIZE_MAX);
    if (flen < (ssize_t)sizeof(*hdr)) {
        errorf("too short");
        memory_free(frame);
        return -1;
    }
    hdr = (struct ether_hdr *)frame;
    if (memcmp(dev->addr, hdr->dst, ETHER_ADDR_LEN) != 0) {
        if (memcmp(ETHER_ADDR_BROADCAST, hdr->dst, ETHER_ADDR_LEN) != 0) {
            /* for other host */
            memory_free(frame);
            return -1;
        }
    }
    type = ntoh16(hdr->type);
    debugf("dev=%s, type=0x%04x, len=%zd", dev->name, type, flen);
    ether_dump(frame, flen);
    ret = net_input_handler(type, (uint8_t *)(hdr+1), flen - sizeof(*hdr), dev);
    memory_free(frame);
    return ret;
}

void
ether_setup_helper(struct net_device *dev)
{
    dev->type = NET_DEVICE_TYPE_ETHERNET;
    dev->mtu = ETHER_PAYLOAD_SIZE_MAX;
    dev->flags = (NET_DEVICE_FLAG_BROADCAST | NET_DEVICE_FLAG_NEED_ARP);
    dev->hlen = ETHER_HDR_SIZE;
    dev->alen = ETHER_ADDR_LEN;
    memcpy(dev->broadcast, ETHER_ADDR_BROADCAST, ETHER_ADDR_LEN);
}
```
</details>

#### ✅ デバイスドライバの修正

Ethernetモジュールを追加したことによりヘルパー関数を使用できるようになりました。これに合わせてe1000ドライバを修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/driver/e1000.c</span></summary>

```diff
 #include "platform.h"

 #include "param.h"
 #include "proc.h"
 #include "memlayout.h"
 #include "pci.h"

 #include "util.h"
 #include "net.h"
+#include "ether.h"

...

+static ssize_t
+e1000_write(struct net_device *dev, const uint8_t *data, size_t len)
+{
+    struct e1000 *e1000;
+    uint32_t tail;
+    struct tx_desc *desc;
+
+    e1000 = PRIV(dev);
+    tail = e1000_reg_read(e1000, E1000_TDT);
+    desc = &e1000->tx_ring[tail];
+    desc->addr = (uint64_t)V2P(data);
+    desc->length = len;
+    desc->status = 0;
+    desc->cmd = (E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS);
+    debugf("dev=%s, %u bytes data transmit", e1000->dev->name, desc->length);
+    e1000_reg_write(e1000, E1000_TDT, (tail + 1) % TX_RING_SIZE);
+    while(!(desc->status & 0x0f)) {
+        microdelay(1);
+    }
+    return len;
+}
+
 static ssize_t
 e1000_transmit(struct net_device *dev, uint16_t type, const uint8_t *packet, size_t len, const void *dst)
 {
-    return 0;
+    return ether_transmit_helper(dev, type, packet, len, dst, e1000_write);
+}
+
+static ssize_t
+e1000_read(struct net_device *dev, uint8_t *buf, size_t size)
+{
+    struct e1000 *e1000;
+    uint32_t tail;
+    struct rx_desc *desc;
+
+    e1000 = PRIV(dev);
+    tail = (e1000_reg_read(e1000, E1000_RDT)+1) % RX_RING_SIZE;
+    desc = &e1000->rx_ring[tail];
+    if (!(desc->status & E1000_RXD_STAT_EOP)) {
+        errorf("not EOP! this driver does not support packet that do not fit in one buffer");
+        return -1;
+    }
+    if (desc->errors) {
+        errorf("rx errors (0x%x)", desc->errors);
+        return -1;
+    }
+    memcpy(buf, P2V((uint32_t)desc->addr), desc->length);
+    return desc->length;
 }

 void
 e1000intr(void)
 {
     struct e1000 *e1000;
     int icr;
     uint32_t tail;
     struct rx_desc *desc;

     debugf(">>>");
     for (e1000 = devices; e1000; e1000 = e1000->next) {
         icr = e1000_reg_read(e1000, E1000_ICR);
         if (icr & E1000_ICR_RXT0) {
             while (1) {
                 tail = (e1000_reg_read(e1000, E1000_RDT)+1) % RX_RING_SIZE;
                 desc = &e1000->rx_ring[tail];
                 if (!(desc->status & E1000_RXD_STAT_DD)) {
                     /* EMPTY */
                     break;
                 }
-                do {
-                    if (!(desc->status & E1000_RXD_STAT_EOP)) {
-                        errorf("not EOP! this driver does not support packet that do not fit in one buffer");
-                        break;
-                    }
-                    if (desc->errors) {
-                        errorf("rx errors (0x%x)", desc->errors);
-                        break;
-                    }
-                    debugf("%d bytes data receive", desc->length);
-                    debugdump(P2V((uint32_t)desc->addr), desc->length);
-                } while(0);

+                ether_input_helper(e1000->dev, e1000_read);
                 desc->status = (uint16_t)(0);
                 e1000_reg_write(e1000, E1000_RDT, tail);
             }
             // clear pending interrupts
             e1000_reg_read(e1000, E1000_ICR);
         }
     }
     debugf("<<<");
 }

...

 int
 e1000init(struct pci_func *pcif)
 {
     struct e1000 *e1000;
     uint8_t addr[6];
     struct net_device *dev;
+    char mac[ETHER_ADDR_STR_LEN];

     e1000 = (struct e1000 *)memory_alloc(sizeof(*e1000));
     if (!e1000) {
         errorf("memory_alloc() failure");
         return -1;
     }
     pci_func_enable(pcif);
     e1000->mmio_base = e1000_resolve_mmio_base(pcif);
     e1000_read_addr_from_eeprom(e1000, addr);
-    debugf("addr: %02x:%02x:%02x:%02x:%02x:%02x",
-        addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
     for (int n = 0; n < 128; n++)
         e1000_reg_write(e1000, E1000_MTA + (n << 2), 0);
     e1000_rx_init(e1000);
     e1000_tx_init(e1000);
     e1000->irq = pcif->irq_line;
     dev = net_device_alloc();
     if (!dev) {
         errorf("net_device_alloc() failure");
         memory_free(e1000);
         return -1;
     }
+    ether_setup_helper(dev);
     memcpy(dev->addr, addr, sizeof(addr));
     dev->priv = e1000;
     dev->ops = &e1000_ops;
     if (net_device_register(dev) == -1) {
         errorf("nt_device_register() failure");
         memory_free(dev);
         memory_free(e1000);
         return -1;
     }
     e1000->dev = dev;
     e1000->next = devices;
     devices = e1000;
     ioapicenable(e1000->irq, ncpu - 1);
-    infof("initialized, irq=%d", e1000->irq);
+    infof("initialized, irq=%d, addr=%s",
+        e1000->irq, ether_addr_ntop(dev->addr, mac, sizeof(mac)));
     return 0;
 }
```
</details>

送受信処理を追加したことにより、プロトコルスタックとのあいだでデータの受け渡しができるようになります。

#### ✅ Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
...
 	net/platform/xv6/std.o\
 	net/platform/xv6/driver/e1000.o\
 	net/util.o\
 	net/net.o\
+	net/ether.o\

```
</details>

#### ✅ 動作確認

再ビルドした後、`make qemu-nox`を実行してxv6を起動させます。

開発環境で別のシェルを開いて、QEMUのTapデバイスにルーティングされるアドレスに`ping`を実行してみます。

```
$ ping 192.0.2.2
```

xv6のログメッセージを確認してみましょう。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
07:08:41.000 [I] net_init: initialized (net/net.c:369)
PCI: 00:00.0: 8086:1237: class: 6.0 (Bridge device) irq: 0
PCI: 00:01.0: 8086:7000: class: 6.1 (Bridge device) irq: 0
PCI: 00:01.1: 8086:7010: class: 1.1 (Storage controller) irq: 0
PCI: 00:01.3: 8086:7113: class: 6.80 (Bridge device) irq: 9
PCI: 00:02.0: 1234:1111: class: 3.0 (Display controller) irq: 0
PCI: 00:03.0: 8086:100e: class: 2.0 (Network controller) irq: 11
PCI function 00:03.0 (8086:100e) enabled
07:08:41.000 [I] net_device_register: registered, dev=net0, type=0x0002 (net/net.c:61)
07:08:41.000 [I] e1000init: initialized, irq=11, addr=52:54:00:12:34:56 (net/platform/xv6/driver/e1000.c:302)
07:08:41.000 [D] net_run: open all devices... (net/net.c:311)
07:08:41.000 [I] net_device_open: dev=net0, state=up (net/net.c:79)
07:08:41.000 [D] net_run: running... (net/net.c:315)
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$ 07:08:42.000 [D] e1000intr: >>> (net/platform/xv6/driver/e1000.c:233)
07:08:42.000 [D] ether_input_helper: dev=net0, type=0x0806, len=60 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
+------+-------------------------------------------------+------------------+
| 0000 | ff ff ff ff ff ff 16 2a af 19 b5 91 08 06 00 01 | .......*........ |
| 0010 | 08 00 06 04 00 01 16 2a af 19 b5 91 c0 00 02 01 | .......*........ |
| 0020 | 00 00 00 00 00 00 c0 00 02 02 00 00 00 00 00 00 | ................ |
| 0030 | 00 00 00 00 00 00 00 00 00 00 00 00             | ............     |
+------+-------------------------------------------------+------------------+
07:08:42.000 [D] e1000intr: <<< (net/platform/xv6/driver/e1000.c:252)
...
```
</details>

## 4.3. IPモジュール

自作プロトコルスタックのIPモジュールを移植します。

#### ✅ IPモジュールのコードの追加

IPモジュールのコードを追加します。

送信パケットを構築するバッファを動的メモリ確保に変更しています。合わせてIPパケットの最大長の定数（`IP_TOTAL_SIZE_MAX`）を`1500`に変更しています。

また、ARPモジュールを移植するまでの暫定処置として、ARPによるアドレス解決をコメントアウトしています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/ip.h</span></summary>

```c
#ifndef IP_H
#define IP_H

#include "platform.h"

#include "net.h"

#define IP_VERSION_IPV4 4

#define IP_HDR_SIZE_MIN 20
#define IP_HDR_SIZE_MAX 60

#define IP_TOTAL_SIZE_MAX 1500
#define IP_PAYLOAD_SIZE_MAX (IP_TOTAL_SIZE_MAX - IP_HDR_SIZE_MIN)

#define IP_ADDR_LEN 4
#define IP_ADDR_STR_LEN 16 /* "ddd.ddd.ddd.ddd\0" */

#define IP_ENDPOINT_STR_LEN (IP_ADDR_STR_LEN + 6) /* xxx.xxx.xxx.xxx:yyyyy\n */

/* see https://www.iana.org/assignments/protocol-numbers/protocol-numbers.txt */
#define IP_PROTOCOL_ICMP  1
#define IP_PROTOCOL_TCP   6
#define IP_PROTOCOL_UDP  17

typedef uint32_t ip_addr_t;

struct ip_endpoint {
    ip_addr_t addr;
    uint16_t port;
};

struct ip_iface {
    struct net_iface iface;
    struct ip_iface *next;
    ip_addr_t unicast;
    ip_addr_t netmask;
    ip_addr_t broadcast;
};

extern const ip_addr_t IP_ADDR_ANY;
extern const ip_addr_t IP_ADDR_BROADCAST;

extern int
ip_addr_pton(const char *p, ip_addr_t *n);
extern char *
ip_addr_ntop(ip_addr_t n, char *p, size_t size);
extern int
ip_endpoint_pton(const char *p, struct ip_endpoint *n);
extern char *
ip_endpoint_ntop(const struct ip_endpoint *n, char *p, size_t size);

extern int
ip_route_set_default_gateway(struct ip_iface *iface, const char *gateway);
extern struct ip_iface *
ip_route_get_iface(ip_addr_t dst);

extern struct ip_iface *
ip_iface_alloc(const char *addr, const char *netmask);
extern int
ip_iface_register(struct net_device *dev, struct ip_iface *iface);
extern struct ip_iface *
ip_iface_select(ip_addr_t addr);

extern ssize_t
ip_output(uint8_t protocol, const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst);

extern int
ip_protocol_register(uint8_t type, void (*handler)(const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst, struct ip_iface *iface));

extern int
ip_init(void);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/ip.c</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "net.h"
//#include "arp.h"
#include "ip.h"

struct ip_hdr {
    uint8_t vhl;
    uint8_t tos;
    uint16_t total;
    uint16_t id;
    uint16_t offset;
    uint8_t ttl;
    uint8_t protocol;
    uint16_t sum;
    ip_addr_t src;
    ip_addr_t dst;
    uint8_t options[];
};

struct ip_protocol {
    struct ip_protocol *next;
    uint8_t type;
    void (*handler)(const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst, struct ip_iface *iface);
};

struct ip_route {
    struct ip_route *next;
    ip_addr_t network;
    ip_addr_t netmask;
    ip_addr_t nexthop;
    struct ip_iface *iface;
};

const ip_addr_t IP_ADDR_ANY       = 0x00000000; /* 0.0.0.0 */
const ip_addr_t IP_ADDR_BROADCAST = 0xffffffff; /* 255.255.255.255 */

/* NOTE: if you want to add/delete the entries after net_run(), you need to protect these lists with a mutex. */
static struct ip_iface *ifaces;
static struct ip_protocol *protocols;
static struct ip_route *routes;

int
ip_addr_pton(const char *p, ip_addr_t *n)
{
    char *sp, *ep;
    int idx;
    long ret;

    sp = (char *)p;
    for (idx = 0; idx < 4; idx++) {
        ret = strtol(sp, &ep, 10);
        if (ret < 0 || ret > 255) {
            return -1;
        }
        if (ep == sp) {
            return -1;
        }
        if ((idx == 3 && *ep != '\0') || (idx != 3 && *ep != '.')) {
            return -1;
        }
        ((uint8_t *)n)[idx] = ret;
        sp = ep + 1;
    }
    return 0;
}

char *
ip_addr_ntop(ip_addr_t n, char *p, size_t size)
{
    uint8_t *u8;

    u8 = (uint8_t *)&n;
    snprintf(p, size, "%d.%d.%d.%d", u8[0], u8[1], u8[2], u8[3]);
    return p;
}

int
ip_endpoint_pton(const char *p, struct ip_endpoint *n)
{
    char *sep;
    char addr[IP_ADDR_STR_LEN] = {};
    long int port;

    sep = strrchr(p, ':');
    if (!sep) {
        return -1;
    }
    memcpy(addr, p, sep - p);
    if (ip_addr_pton(addr, &n->addr) == -1) {
        return -1;
    }
    port = strtol(sep+1, NULL, 10);
    if (port <= 0 || port > UINT16_MAX) {
        return -1;
    }
    n->port = hton16(port);
    return 0;
}

char *
ip_endpoint_ntop(const struct ip_endpoint *n, char *p, size_t size)
{
    size_t offset;

    ip_addr_ntop(n->addr, p, size);
    offset = strlen(p);
    snprintf(p + offset, size - offset, ":%d", ntoh16(n->port));
    return p;
}

static void
ip_dump(const uint8_t *data, size_t len)
{
    struct ip_hdr *hdr;
    uint8_t v, hl, hlen;
    uint16_t total, offset;
    char addr[IP_ADDR_STR_LEN];

    flockfile(stderr);
    hdr = (struct ip_hdr *)data;
    v = (hdr->vhl & 0xf0) >> 4;
    hl = hdr->vhl & 0x0f;
    hlen = hl << 2;
    fprintf(stderr, "        vhl: 0x%02x [v: %u, hl: %u (%u)]\n", hdr->vhl, v, hl, hlen);
    fprintf(stderr, "        tos: 0x%02x\n", hdr->tos);
    total = ntoh16(hdr->total);
    fprintf(stderr, "      total: %u (payload: %u)\n", total, total - hlen);
    fprintf(stderr, "         id: %u\n", ntoh16(hdr->id));
    offset = ntoh16(hdr->offset);
    fprintf(stderr, "     offset: 0x%04x [flags=%x, offset=%u]\n", offset, (offset & 0xe000) >> 13, offset & 0x1fff);
    fprintf(stderr, "        ttl: %u\n", hdr->ttl);
    fprintf(stderr, "   protocol: %u\n", hdr->protocol);
    fprintf(stderr, "        sum: 0x%04x\n", ntoh16(hdr->sum));
    fprintf(stderr, "        src: %s\n", ip_addr_ntop(hdr->src, addr, sizeof(addr)));
    fprintf(stderr, "        dst: %s\n", ip_addr_ntop(hdr->dst, addr, sizeof(addr)));
#ifdef HEXDUMP
    hexdump(stderr, data, len);
#endif
    funlockfile(stderr);
}

/* NOTE: must not be call after net_run() */
static struct ip_route *
ip_route_add(ip_addr_t network, ip_addr_t netmask, ip_addr_t nexthop, struct ip_iface *iface)
{
    struct ip_route *route;
    char addr1[IP_ADDR_STR_LEN];
    char addr2[IP_ADDR_STR_LEN];
    char addr3[IP_ADDR_STR_LEN];
    char addr4[IP_ADDR_STR_LEN];

    route = memory_alloc(sizeof(*route));
    if (!route) {
        errorf("memory_alloc() failure");
        return NULL;
    }
    route->network = network;
    route->netmask = netmask;
    route->nexthop = nexthop;
    route->iface = iface;
    route->next = routes;
    routes = route;
    infof("route added: network=%s, netmask=%s, nexthop=%s, iface=%s dev=%s",
        ip_addr_ntop(route->network, addr1, sizeof(addr1)),
        ip_addr_ntop(route->netmask, addr2, sizeof(addr2)),
        ip_addr_ntop(route->nexthop, addr3, sizeof(addr3)),
        ip_addr_ntop(route->iface->unicast, addr4, sizeof(addr4)),
        NET_IFACE(iface)->dev->name
    );
    return route;
}

static struct ip_route *
ip_route_lookup(ip_addr_t dst)
{
    struct ip_route *route, *candidate = NULL;

    for (route = routes; route; route = route->next) {
        if ((dst & route->netmask) == route->network) {
            if (!candidate || ntoh32(candidate->netmask) < ntoh32(route->netmask)) {
                candidate = route;
            }
        }
    }
    return candidate;
}

/* NOTE: must not be call after net_run() */
int
ip_route_set_default_gateway(struct ip_iface *iface, const char *gateway)
{
    ip_addr_t gw;

    if (ip_addr_pton(gateway, &gw) == -1) {
        errorf("ip_addr_pton() failure, addr=%s", gateway);
        return -1;
    }
    if (!ip_route_add(IP_ADDR_ANY, IP_ADDR_ANY, gw, iface)) {
        errorf("ip_route_add() failure");
        return -1;
    }
    return 0;
}

struct ip_iface *
ip_route_get_iface(ip_addr_t dst)
{
    struct ip_route *route;

    route = ip_route_lookup(dst);
    if (!route) {
        return NULL;
    }
    return route->iface;
}

struct ip_iface *
ip_iface_alloc(const char *unicast, const char *netmask)
{
    struct ip_iface *iface;

    iface = memory_alloc(sizeof(*iface));
    if (!iface) {
        errorf("memory_alloc() failure");
        return NULL;
    }
    NET_IFACE(iface)->family = NET_IFACE_FAMILY_IP;
    if (ip_addr_pton(unicast, &iface->unicast) == -1) {
        errorf("ip_addr_pton() failure, addr=%s", unicast);
        memory_free(iface);
        return NULL;
    }
    if (ip_addr_pton(netmask, &iface->netmask) == -1) {
        errorf("ip_addr_pton() failure, addr=%s", netmask);
        memory_free(iface);
        return NULL;
    }
    iface->broadcast = (iface->unicast & iface->netmask) | ~iface->netmask;
    return iface;
}

/* NOTE: must not be call after net_run() */
int
ip_iface_register(struct net_device *dev, struct ip_iface *iface)
{
    char addr1[IP_ADDR_STR_LEN];
    char addr2[IP_ADDR_STR_LEN];
    char addr3[IP_ADDR_STR_LEN];

    if (net_device_add_iface(dev, NET_IFACE(iface)) == -1) {
        errorf("net_device_add_iface() failure");
        return -1;
    }
    if (!ip_route_add(iface->unicast & iface->netmask, iface->netmask, IP_ADDR_ANY, iface)) {
        errorf("ip_route_add() failure");
        return -1;
    }
    iface->next = ifaces;
    ifaces = iface;
    infof("registered: dev=%s, unicast=%s, netmask=%s, broadcast=%s", dev->name,
        ip_addr_ntop(iface->unicast, addr1, sizeof(addr1)),
        ip_addr_ntop(iface->netmask, addr2, sizeof(addr2)),
        ip_addr_ntop(iface->broadcast, addr3, sizeof(addr3)));
    return 0;
}

struct ip_iface *
ip_iface_select(ip_addr_t addr)
{
    struct ip_iface *entry;

    for (entry = ifaces; entry; entry = entry->next) {
        if (entry->unicast == addr) {
            break;
        }
    }
    return entry;
}

/* NOTE: must not be call after net_run() */
int
ip_protocol_register(uint8_t type, void (*handler)(const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst, struct ip_iface *iface))
{
    struct ip_protocol *entry;

    for (entry = protocols; entry; entry = entry->next) {
        if (entry->type == type) {
            errorf("already exists, type=%u", type);
            return -1;
        }
    }
    entry = memory_alloc(sizeof(*entry));
    if (!entry) {
        errorf("memory_alloc() failure");
        return -1;
    }
    entry->type = type;
    entry->handler = handler;
    entry->next = protocols;
    protocols = entry;
    infof("registered, type=%u", entry->type);
    return 0;
}

static void
ip_input(const uint8_t *data, size_t len, struct net_device *dev)
{
    struct ip_hdr *hdr;
    uint8_t v;
    uint16_t hlen, total, offset;
    struct ip_iface *iface;
    char addr[IP_ADDR_STR_LEN];
    struct ip_protocol *proto;

    if (len < IP_HDR_SIZE_MIN) {
        errorf("too short");
        return;
    }
    hdr = (struct ip_hdr *)data;
    v = hdr->vhl >> 4;
    if (v != IP_VERSION_IPV4) {
        errorf("ip version error: v=%u", v);
        return;
    }
    hlen = (hdr->vhl & 0x0f) << 2;
    if (len < hlen) {
        errorf("header length error: len=%zu < hlen=%u", len, hlen);
        return;
    }
    total = ntoh16(hdr->total);
    if (len < total) {
        errorf("total length error: len=%zu < total=%u", len, total);
        return;
    }
    if (cksum16((uint16_t *)hdr, hlen, 0) != 0) {
        errorf("checksum error: sum=0x%04x, verify=0x%04x", ntoh16(hdr->sum), ntoh16(cksum16((uint16_t *)hdr, hlen, -hdr->sum)));
        return;
    }
    offset = ntoh16(hdr->offset);
    if (offset & 0x2000 || offset & 0x1fff) {
        errorf("fragments does not support");
        return;
    }
    iface = (struct ip_iface *)net_device_get_iface(dev, NET_IFACE_FAMILY_IP);
    if (!iface) {
        /* iface is not registered to the device */
        return;
    }
    if (hdr->dst != iface->unicast) {
        if (hdr->dst != iface->broadcast && hdr->dst != IP_ADDR_BROADCAST) {
            /* for other host */
            return;
        }
    }
    debugf("dev=%s, iface=%s, protocol=%u, total=%u",
        dev->name, ip_addr_ntop(iface->unicast, addr, sizeof(addr)), hdr->protocol, total);
    ip_dump(data, total);
    for (proto = protocols; proto; proto = proto->next) {
        if (proto->type == hdr->protocol) {
            proto->handler((uint8_t *)hdr + hlen, total - hlen, hdr->src, hdr->dst, iface);
            return;
        }
    }
    /* unsupported protocol */
}

static int
ip_output_device(struct ip_iface *iface, const uint8_t *data, size_t len, ip_addr_t dst)
{
    uint8_t hwaddr[NET_DEVICE_ADDR_LEN] = {};
//    int ret;

    if (NET_IFACE(iface)->dev->flags & NET_DEVICE_FLAG_NEED_ARP) {
        if (dst == iface->broadcast || dst == IP_ADDR_BROADCAST) {
            memcpy(hwaddr, NET_IFACE(iface)->dev->broadcast, NET_IFACE(iface)->dev->alen);
        } else {
/*
            ret = arp_resolve(NET_IFACE(iface), dst, hwaddr);
            if (ret != ARP_RESOLVE_FOUND) {
                return ret;
            }
*/
            return -1;
        }
    }
    return net_device_output(NET_IFACE(iface)->dev, NET_PROTOCOL_TYPE_IP, data, len, hwaddr);
}

static ssize_t
ip_output_core(struct ip_iface *iface, uint8_t protocol, const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst, ip_addr_t nexthop, uint16_t id, uint16_t offset)
{
    uint8_t *buf;
    struct ip_hdr *hdr;
    uint16_t hlen, total;
    char addr[IP_ADDR_STR_LEN];
    ssize_t ret;

    buf = memory_alloc(IP_TOTAL_SIZE_MAX);
    if (!buf) {
        return -1;
    }
    hdr = (struct ip_hdr *)buf;
    hlen = IP_HDR_SIZE_MIN;
    hdr->vhl = (IP_VERSION_IPV4 << 4) | (hlen >> 2);
    hdr->tos = 0;
    total = hlen + len;
    hdr->total = hton16(total);
    hdr->id = hton16(id);
    hdr->offset = hton16(offset);
    hdr->ttl = 0xff;
    hdr->protocol = protocol;
    hdr->sum = 0;
    hdr->src = src;
    hdr->dst = dst;
    hdr->sum = cksum16((uint16_t *)hdr, hlen, 0); /* don't convert byteoder */
    memcpy(hdr+1, data, len);
    debugf("dev=%s, dst=%s, protocol=%u, len=%u",
        NET_IFACE(iface)->dev->name, ip_addr_ntop(dst, addr, sizeof(addr)), protocol, total);
    ip_dump(buf, total);
    ret = ip_output_device(iface, buf, total, nexthop);
    memory_free(buf);
    return ret;
}

static uint16_t
ip_generate_id(void)
{
    static mutex_t mutex = MUTEX_INITIALIZER;
    static uint16_t id = 128;
    uint16_t ret;

    mutex_lock(&mutex);
    ret = id++;
    mutex_unlock(&mutex);
    return ret;
}

ssize_t
ip_output(uint8_t protocol, const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst)
{
    struct ip_route *route;
    struct ip_iface *iface;
    char addr[IP_ADDR_STR_LEN];
    ip_addr_t nexthop;
    uint16_t id;

    if (src == IP_ADDR_ANY &&  dst == IP_ADDR_BROADCAST) {
        errorf("source address is required for broadcast addresses");
        return -1;
    }
    route = ip_route_lookup(dst);
    if (!route) {
        errorf("no route to host, dst=%s", ip_addr_ntop(dst, addr, sizeof(addr)));
        return -1;
    }
    iface = route->iface;
    if (src != IP_ADDR_ANY && src != iface->unicast) {
        errorf("unable to output with specified source address, src=%s", ip_addr_ntop(src, addr, sizeof(addr)));
        return -1;
    }
    nexthop = (route->nexthop != IP_ADDR_ANY) ? route->nexthop : dst;
    if (NET_IFACE(iface)->dev->mtu < IP_HDR_SIZE_MIN + len) {
        errorf("too long, dev=%s, mtu=%u < %zu",
            NET_IFACE(iface)->dev->name, NET_IFACE(iface)->dev->mtu, IP_HDR_SIZE_MIN + len);
        return -1;
    }
    id = ip_generate_id();
    if (ip_output_core(iface, protocol, data, len, iface->unicast, dst, nexthop, id, 0) == -1) {
        errorf("ip_output_core() failure");
        return -1;
    }
    return len;
}

int
ip_init(void)
{
    if (net_protocol_register(NET_PROTOCOL_TYPE_IP, ip_input) == -1) {
        errorf("net_protocol_register() failure");
        return -1;
    }
    return 0;
}
```
</details>

#### ✅ 環境依存の排他処理

xv6環境での排他処理を追加します。ここではスピンロックを利用ます。xv6のスピンロックは、`struct spinlock`に対して`acquire()`でロックを獲得し、`release()`でロックを解放します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/platform.h</span></summary>

```diff
...

 /*
  * Mutex
  */

 #include "param.h"
 #include "spinlock.h"
 #include "proc.h"

+typedef struct spinlock mutex_t;
+
+#define MUTEX_INITIALIZER {0}
+
+static inline int
+mutex_init(mutex_t *mutex)
+{
+    initlock(mutex, "");
+    return 0;
+}
+
+static inline int
+mutex_lock(mutex_t *mutex)
+{
+    acquire(mutex);
+    return 0;
+}
+
+static inline int
+mutex_unlock(mutex_t *mutex)
+{
+    release(mutex);
+    return 0;
+}

...
```
</details>

#### ✅ 初期化関数の呼び出し

`net_init()`からIPモジュールの初期化関数を呼び出すようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/net.c</span></summary>

```diff
...

+#include "ip.h"

 int
 net_init(void)
 {
     if (intr_init() == -1) {
         errorf("intr_init() failure");
         return -1;
     }
+    if (ip_init() == -1) {
+        errorf("ip_init() failure");
+        return -1;
+    }
     infof("initialized");
     return 0;
 }
```
</details>

#### ✅ Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
...
 	net/platform/xv6/std.o\
 	net/platform/xv6/driver/e1000.o\
 	net/util.o\
 	net/net.o\
 	net/ether.o\
+	net/ip.o\

```
</details>

#### ✅ IPインタフェースの追加（暫定対応）

IPモジュールを追加したので、IPインタフェースを登録できるようになりました。最終的には`ifconfig`のようなコマンドを通じてインタフェースを設定するのが望ましいですが、いまの時点では暫定的にe1000ドライバの初期化の中でIPインタフェースの登録をしてしまいます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/driver/e1000.c</span></summary>

```diff
...

+#include "ip.h"
+
 int
 e1000init(struct pci_func *pcif)
 {
...
     infof("initialized, irq=%d, addr=%s",
         e1000->irq, ether_addr_ntop(dev->addr, mac, sizeof(mac)));
+    struct ip_iface *iface;
+    iface = ip_iface_alloc("192.0.2.2", "255.255.255.0");
+    if (!iface) {
+        errorf("ip_iface_alloc() failure");
+        return -1;
+    }
+    if (ip_iface_register(dev, iface) == -1) {
+        errorf("ip_iface_register() failure");
+        return -1;
+    }
     return 0;
 }
```
</details>

やや無理やりな方法ではありますが、IPネットワークでの通信に必要なIPアドレスを持たせることができます。

#### ✅ 動作確認

再ビルドした後、`make qemu-nox`を実行してxv6を起動します。`net0`に対して`192.0.2.2.`のアドレスを持つIPインタフェースが登録されていることが確認できます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
08:13:18.000 [I] net_protocol_register: registered, type=0x0800 (net/net.c:174)
08:13:18.000 [I] net_init: initialized (net/net.c:373)
PCI: 00:00.0: 8086:1237: class: 6.0 (Bridge device) irq: 0
PCI: 00:01.0: 8086:7000: class: 6.1 (Bridge device) irq: 0
PCI: 00:01.1: 8086:7010: class: 1.1 (Storage controller) irq: 0
PCI: 00:01.3: 8086:7113: class: 6.80 (Bridge device) irq: 9
PCI: 00:02.0: 1234:1111: class: 3.0 (Display controller) irq: 0
PCI: 00:03.0: 8086:100e: class: 2.0 (Network controller) irq: 11
PCI function 00:03.0 (8086:100e) enabled
08:13:18.000 [I] net_device_register: registered, dev=net0, type=0x0002 (net/net.c:61)
08:13:18.000 [I] e1000init: initialized, irq=11, addr=52:54:00:12:34:56 (net/platform/xv6/driver/e1000.c:302)
08:13:18.000 [I] ip_route_add: route added: network=192.0.2.0, netmask=255.255.255.0, nexthop=0.0.0.0, iface=192.0.2.2 dev=net0 (net/ip.c:165)
08:13:18.000 [I] ip_iface_register: registered: dev=net0, unicast=192.0.2.2, netmask=255.255.255.0, broadcast=192.0.2.255 (net/ip.c:262)
08:13:18.000 [D] net_run: open all devices... (net/net.c:311)
08:13:18.000 [I] net_device_open: dev=net0, state=up (net/net.c:79)
08:13:18.000 [D] net_run: running... (net/net.c:315)
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
```
</details>

開発環境で別のシェルを開き、`192.0.2.255`に対して`ping`を実行します。ブロードキャストアドレス宛なので`-b`のオプションを指定してください。宛先がブロードキャストアドレスなのは、ARPによるアドレス解決をスキップして即座にIPパケットを送信できるからです。

```
$ ping -b 192.0.2.255
```

`ping`コマンドを実行しても応答は得られませんが、パケットがIPモジュールまで渡わたっていることが確認できます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
08:13:19.000 [D] e1000intr: >>> (net/platform/xv6/driver/e1000.c:231)
08:13:19.000 [D] ether_input_helper: dev=net0, type=0x0800, len=98 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0800
+------+-------------------------------------------------+------------------+
| 0000 | ff ff ff ff ff ff 16 2a af 19 b5 91 08 00 45 00 | .......*......E. |
| 0010 | 00 54 00 00 40 00 40 01 b5 a8 c0 00 02 01 c0 00 | .T..@.@......... |
| 0020 | 02 ff 08 00 ff 34 00 16 04 88 9e 15 bb 66 00 00 | .....4.......f.. |
| 0030 | 00 00 d3 dd 08 00 00 00 00 00 10 11 12 13 14 15 | ................ |
| 0040 | 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 | .......... !"#$% |
| 0050 | 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 | &'()*+,-./012345 |
| 0060 | 36 37                                           | 67               |
+------+-------------------------------------------------+------------------+
08:13:19.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0800, len=84 (net/net.c:236)
+------+-------------------------------------------------+------------------+
| 0000 | 45 00 00 54 00 00 40 00 40 01 b5 a8 c0 00 02 01 | E..T..@.@....... |
| 0010 | c0 00 02 ff 08 00 ff 34 00 16 04 88 9e 15 bb 66 | .......4.......f |
| 0020 | 00 00 00 00 d3 dd 08 00 00 00 00 00 10 11 12 13 | ................ |
| 0030 | 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 | ............ !"# |
| 0040 | 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 | $%&'()*+,-./0123 |
| 0050 | 34 35 36 37                                     | 4567             |
+------+-------------------------------------------------+------------------+
08:13:19.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0800, len=84 (net/net.c:258)
+------+-------------------------------------------------+------------------+
| 0000 | 45 00 00 54 00 00 40 00 40 01 b5 a8 c0 00 02 01 | E..T..@.@....... |
| 0010 | c0 00 02 ff 08 00 ff 34 00 16 04 88 9e 15 bb 66 | .......4.......f |
| 0020 | 00 00 00 00 d3 dd 08 00 00 00 00 00 10 11 12 13 | ................ |
| 0030 | 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 | ............ !"# |
| 0040 | 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 | $%&'()*+,-./0123 |
| 0050 | 34 35 36 37                                     | 4567             |
+------+-------------------------------------------------+------------------+
08:13:19.000 [D] ip_input: dev=net0, iface=192.0.2.2, protocol=1, total=84 (net/ip.c:357)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 84 (payload: 64)
         id: 0
     offset: 0x4000 [flags=2, offset=0]
        ttl: 64
   protocol: 1
        sum: 0xb5a8
        src: 192.0.2.1
        dst: 192.0.2.255
+------+-------------------------------------------------+------------------+
| 0000 | 45 00 00 54 00 00 40 00 40 01 b5 a8 c0 00 02 01 | E..T..@.@....... |
| 0010 | c0 00 02 ff 08 00 ff 34 00 16 04 88 9e 15 bb 66 | .......4.......f |
| 0020 | 00 00 00 00 d3 dd 08 00 00 00 00 00 10 11 12 13 | ................ |
| 0030 | 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 | ............ !"# |
| 0040 | 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 | $%&'()*+,-./0123 |
| 0050 | 34 35 36 37                                     | 4567             |
+------+-------------------------------------------------+------------------+
08:13:19.000 [D] e1000intr: <<< (net/platform/xv6/driver/e1000.c:250)
...
```
</details>

## 4.4. ARPモジュール

自作プロトコルスタックのARPモジュールを移植します。

#### ✅ ARPモジュールのコードの追加

ARPモジュールのコードを追加します。変更点はシステムヘッダのインクルード削除のみです。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/arp.h</span></summary>

```c
#ifndef ARP_H
#define ARP_H

#include "platform.h"

#include "net.h"
#include "ip.h"

#define ARP_RESOLVE_ERROR      -1
#define ARP_RESOLVE_INCOMPLETE  0
#define ARP_RESOLVE_FOUND       1

extern int
arp_resolve(struct net_iface *iface, ip_addr_t pa, uint8_t *ha);

extern int
arp_init(void);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/arp.c</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "net.h"
#include "ether.h"
#include "arp.h"
#include "ip.h"

/* see https://www.iana.org/assignments/arp-parameters/arp-parameters.txt */
#define ARP_HRD_ETHER 0x0001
/* NOTE: use same value as the Ethernet types */
#define ARP_PRO_IP ETHER_TYPE_IP

#define ARP_OP_REQUEST 1
#define ARP_OP_REPLY   2

#define ARP_CACHE_SIZE 32
#define ARP_CACHE_TIMEOUT 30 /* seconds */

#define ARP_CACHE_STATE_FREE       0
#define ARP_CACHE_STATE_INCOMPLETE 1
#define ARP_CACHE_STATE_RESOLVED   2
#define ARP_CACHE_STATE_STATIC     3

struct arp_hdr {
    uint16_t hrd;
    uint16_t pro;
    uint8_t hln;
    uint8_t pln;
    uint16_t op;
};

struct arp_ether_ip {
    struct arp_hdr hdr;
    uint8_t sha[ETHER_ADDR_LEN];
    uint8_t spa[IP_ADDR_LEN];
    uint8_t tha[ETHER_ADDR_LEN];
    uint8_t tpa[IP_ADDR_LEN];
};

struct arp_cache {
    unsigned char state;
    ip_addr_t pa;
    uint8_t ha[ETHER_ADDR_LEN];
    struct timeval timestamp;
};

static mutex_t mutex = MUTEX_INITIALIZER;
static struct arp_cache caches[ARP_CACHE_SIZE];

static char *
arp_opcode_ntoa(uint16_t opcode)
{
    switch (ntoh16(opcode)) {
    case ARP_OP_REQUEST:
        return "Request";
    case ARP_OP_REPLY:
        return "Reply";
    }
    return "Unknown";
}

static void
arp_dump(const uint8_t *data, size_t len)
{
    struct arp_ether_ip *message;
    ip_addr_t spa, tpa;
    char addr[128];

    message = (struct arp_ether_ip *)data;
    flockfile(stderr);
    fprintf(stderr, "        hrd: 0x%04x\n", ntoh16(message->hdr.hrd));
    fprintf(stderr, "        pro: 0x%04x\n", ntoh16(message->hdr.pro));
    fprintf(stderr, "        hln: %u\n", message->hdr.hln);
    fprintf(stderr, "        pln: %u\n", message->hdr.pln);
    fprintf(stderr, "         op: %u (%s)\n", ntoh16(message->hdr.op), arp_opcode_ntoa(message->hdr.op));
    fprintf(stderr, "        sha: %s\n", ether_addr_ntop(message->sha, addr, sizeof(addr)));
    memcpy(&spa, message->spa, sizeof(spa));
    fprintf(stderr, "        spa: %s\n", ip_addr_ntop(spa, addr, sizeof(addr)));
    fprintf(stderr, "        tha: %s\n", ether_addr_ntop(message->tha, addr, sizeof(addr)));
    memcpy(&tpa, message->tpa, sizeof(tpa));
    fprintf(stderr, "        tpa: %s\n", ip_addr_ntop(tpa, addr, sizeof(addr)));
#ifdef HEXDUMP
    hexdump(stderr, data, len);
#endif
    funlockfile(stderr);
}

/*
 * ARP Cache
 *
 * NOTE: ARP Cache functions must be called after mutex locked
 */

static void
arp_cache_delete(struct arp_cache *cache)
{
    char addr1[IP_ADDR_STR_LEN];
    char addr2[ETHER_ADDR_STR_LEN];

    debugf("DELETE: pa=%s, ha=%s", ip_addr_ntop(cache->pa, addr1, sizeof(addr1)), ether_addr_ntop(cache->ha, addr2, sizeof(addr2)));
    cache->state = ARP_CACHE_STATE_FREE;
    cache->pa = 0;
    memset(cache->ha, 0, ETHER_ADDR_LEN);
    timerclear(&cache->timestamp);
}

static struct arp_cache *
arp_cache_alloc(void)
{
    struct arp_cache *entry, *oldest = NULL;

    for (entry = caches; entry < tailof(caches); entry++) {
        if (entry->state == ARP_CACHE_STATE_FREE) {
            return entry;
        }
        if (!oldest || timercmp(&oldest->timestamp, &entry->timestamp, >)) {
            oldest = entry;
        }
    }
    arp_cache_delete(oldest);
    return oldest;
}

static struct arp_cache *
arp_cache_select(ip_addr_t pa)
{
    struct arp_cache *entry;

    for (entry = caches; entry < tailof(caches); entry++) {
        if (entry->state != ARP_CACHE_STATE_FREE && entry->pa == pa) {
            return entry;
        }
    }
    return NULL;
}

static struct arp_cache *
arp_cache_update(ip_addr_t pa, const uint8_t *ha)
{
    struct arp_cache *cache;
    char addr1[IP_ADDR_STR_LEN];
    char addr2[ETHER_ADDR_STR_LEN];

    cache = arp_cache_select(pa);
    if (!cache) {
        /* not found */
        return NULL;
    }
    cache->state = ARP_CACHE_STATE_RESOLVED;
    memcpy(cache->ha, ha, ETHER_ADDR_LEN);
    gettimeofday(&cache->timestamp, NULL);
    debugf("UPDATE: pa=%s, ha=%s", ip_addr_ntop(pa, addr1, sizeof(addr1)), ether_addr_ntop(ha, addr2, sizeof(addr2)));
    return cache;
}

static struct arp_cache *
arp_cache_insert(ip_addr_t pa, const uint8_t *ha)
{
    struct arp_cache *cache;
    char addr1[IP_ADDR_STR_LEN];
    char addr2[ETHER_ADDR_STR_LEN];

    cache = arp_cache_alloc();
    if (!cache) {
        errorf("arp_cache_alloc() failure");
        return NULL;
    }
    cache->state = ARP_CACHE_STATE_RESOLVED;
    cache->pa = pa;
    memcpy(cache->ha, ha, ETHER_ADDR_LEN);
    gettimeofday(&cache->timestamp, NULL);
    debugf("INSERT: pa=%s, ha=%s", ip_addr_ntop(pa, addr1, sizeof(addr1)), ether_addr_ntop(ha, addr2, sizeof(addr2)));
    return cache;
}

static int
arp_request(struct net_iface *iface, ip_addr_t tpa)
{
    struct arp_ether_ip request;

    request.hdr.hrd = hton16(ARP_HRD_ETHER);
    request.hdr.pro = hton16(ARP_PRO_IP);
    request.hdr.hln = ETHER_ADDR_LEN;
    request.hdr.pln = IP_ADDR_LEN;
    request.hdr.op = hton16(ARP_OP_REQUEST);
    memcpy(request.sha, iface->dev->addr, ETHER_ADDR_LEN);
    memcpy(request.spa, &((struct ip_iface *)iface)->unicast, IP_ADDR_LEN);
    memset(request.tha, 0, ETHER_ADDR_LEN);
    memcpy(request.tpa, &tpa, IP_ADDR_LEN);
    debugf("dev=%s, len=%zu", iface->dev->name, sizeof(request));
    arp_dump((uint8_t *)&request, sizeof(request));
    return net_device_output(iface->dev, ETHER_TYPE_ARP, (uint8_t *)&request, sizeof(request), iface->dev->broadcast);
}

static int
arp_reply(struct net_iface *iface, const uint8_t *tha, ip_addr_t tpa, const uint8_t *dst)
{
    struct arp_ether_ip reply;

    reply.hdr.hrd = hton16(ARP_HRD_ETHER);
    reply.hdr.pro = hton16(ARP_PRO_IP);
    reply.hdr.hln = ETHER_ADDR_LEN;
    reply.hdr.pln = IP_ADDR_LEN;
    reply.hdr.op = hton16(ARP_OP_REPLY);
    memcpy(reply.sha, iface->dev->addr, ETHER_ADDR_LEN);
    memcpy(reply.spa, &((struct ip_iface *)iface)->unicast, IP_ADDR_LEN);
    memcpy(reply.tha, tha, ETHER_ADDR_LEN);
    memcpy(reply.tpa, &tpa, IP_ADDR_LEN);
    debugf("dev=%s, len=%zu", iface->dev->name, sizeof(reply));
    arp_dump((uint8_t *)&reply, sizeof(reply));
    return net_device_output(iface->dev, ETHER_TYPE_ARP, (uint8_t *)&reply, sizeof(reply), dst);
}

static void
arp_input(const uint8_t *data, size_t len, struct net_device *dev)
{
    struct arp_ether_ip *msg;
    ip_addr_t spa, tpa;
    int marge = 0;
    struct net_iface *iface;

    if (len < sizeof(*msg)) {
        errorf("too short");
        return;
    }
    msg = (struct arp_ether_ip *)data;
    if (ntoh16(msg->hdr.hrd) != ARP_HRD_ETHER || msg->hdr.hln != ETHER_ADDR_LEN) {
        errorf("unsupported hardware address");
        return;
    }
    if (ntoh16(msg->hdr.pro) != ARP_PRO_IP || msg->hdr.pln != IP_ADDR_LEN) {
        errorf("unsupported protocol address");
        return;
    }
    debugf("dev=%s, len=%zu", dev->name, len);
    arp_dump(data, len);
    memcpy(&spa, msg->spa, sizeof(spa));
    memcpy(&tpa, msg->tpa, sizeof(tpa));
    mutex_lock(&mutex);
    if (arp_cache_update(spa, msg->sha)) {
        /* updated */
        marge = 1;
    }
    mutex_unlock(&mutex);
    iface = net_device_get_iface(dev, NET_IFACE_FAMILY_IP);
    if (iface && ((struct ip_iface *)iface)->unicast == tpa) {
        if (!marge) {
            mutex_lock(&mutex);
            arp_cache_insert(spa, msg->sha);
            mutex_unlock(&mutex);
        }
        if (ntoh16(msg->hdr.op) == ARP_OP_REQUEST) {
            arp_reply(iface, msg->sha, spa, msg->sha);
        }
    }
}

int
arp_resolve(struct net_iface *iface, ip_addr_t pa, uint8_t *ha)
{
    struct arp_cache *cache;
    char addr1[IP_ADDR_STR_LEN];
    char addr2[ETHER_ADDR_STR_LEN];

    if (iface->dev->type != NET_DEVICE_TYPE_ETHERNET) {
        debugf("unsupported hardware address type");
        return ARP_RESOLVE_ERROR;
    }
    if (iface->family != NET_IFACE_FAMILY_IP) {
        debugf("unsupported protocol address type");
        return ARP_RESOLVE_ERROR;
    }
    mutex_lock(&mutex);
    cache = arp_cache_select(pa);
    if (!cache) {
        debugf("cache not found, pa=%s", ip_addr_ntop(pa, addr1, sizeof(addr1)));
        cache = arp_cache_alloc();
        if (!cache) {
            mutex_unlock(&mutex);
            errorf("arp_cache_alloc() failure");
            return ARP_RESOLVE_ERROR;
        }
        cache->state = ARP_CACHE_STATE_INCOMPLETE;
        cache->pa = pa;
        gettimeofday(&cache->timestamp, NULL);
        mutex_unlock(&mutex);
        arp_request(iface, pa);
        return ARP_RESOLVE_INCOMPLETE;
    }
    if (cache->state == ARP_CACHE_STATE_INCOMPLETE) {
        mutex_unlock(&mutex);
        arp_request(iface, pa); /* just in case packet loss */
        return ARP_RESOLVE_INCOMPLETE;
    }
    memcpy(ha, cache->ha, ETHER_ADDR_LEN);
    mutex_unlock(&mutex);
    debugf("resolved, pa=%s, ha=%s",
        ip_addr_ntop(pa, addr1, sizeof(addr1)), ether_addr_ntop(ha, addr2, sizeof(addr2)));
    return ARP_RESOLVE_FOUND;
}

static void
arp_timer_handler(void)
{
    struct arp_cache *entry;
    struct timeval now, diff;

    mutex_lock(&mutex);
    gettimeofday(&now, NULL);
    for (entry = caches; entry < tailof(caches); entry++) {
        if (entry->state != ARP_CACHE_STATE_FREE && entry->state != ARP_CACHE_STATE_STATIC) {
            timersub(&now, &entry->timestamp, &diff);
            if (diff.tv_sec > ARP_CACHE_TIMEOUT) {
                arp_cache_delete(entry);
            }
        }
    }
    mutex_unlock(&mutex);
}

int
arp_init(void)
{
    struct timeval interval = {1, 0}; /* 1s */

    if (net_protocol_register(NET_PROTOCOL_TYPE_ARP, arp_input) == -1) {
        errorf("net_protocol_register() failure");
        return -1;
    }
    if (net_timer_register(interval, arp_timer_handler) == -1) {
        errorf("net_timer_register() failure");
        return -1;
    }
    return 0;
}
```
</details>

#### ✅ IPモジュールからアドレス解決

IPモジュールで一時的にコメントアウトしていたARPによるアドレス解決をもとに戻します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/ip.c</span></summary>

```diff
...
-//#inlude "arp.h"
+#include "arp.h"
...

 static int
 ip_output_device(struct ip_iface *iface, const uint8_t *data, size_t len, ip_addr_t dst)
 {
     uint8_t hwaddr[NET_DEVICE_ADDR_LEN] = {};
-//    int ret;
+    int ret;

     if (NET_IFACE(iface)->dev->flags & NET_DEVICE_FLAG_NEED_ARP) {
         if (dst == iface->broadcast || dst == IP_ADDR_BROADCAST) {
             memcpy(hwaddr, NET_IFACE(iface)->dev->broadcast, NET_IFACE(iface)->dev->alen);
         } else {
-/*
             ret = arp_resolve(NET_IFACE(iface), dst, hwaddr);
             if (ret != ARP_RESOLVE_FOUND) {
                 return ret;
             }
-*/
-            return -1;
         }
     }
     return net_device_output(NET_IFACE(iface)->dev, NET_PROTOCOL_TYPE_IP, data, len, hwaddr);
 }

...
```
</details>

#### ✅ 初期化関数の呼び出し

`net_init()`からARPモジュールの初期化関数を呼び出すようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/net.c</span></summary>

```diff
...

+#include "arp.h"
 #include "ip.h"

 int
 net_init(void)
 {
     if (intr_init() == -1) {
         errorf("intr_init() failure");
         return -1;
     }
+    if (arp_init() == -1) {
+        errorf("arp_init() failure");
+        return -1;
+    }
     if (ip_init() == -1) {
         errorf("ip_init() failure");
         return -1;
     }
     infof("initialized");
     return 0;
 }
```
</details>

#### ✅ Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
...
 	net/platform/xv6/std.o\
 	net/platform/xv6/driver/e1000.o\
 	net/util.o\
 	net/net.o\
 	net/ether.o\
+	net/arp.o\
 	net/ip.o\

```
</details>

#### ✅ 動作確認

再ビルドした後、`make qemu-nox`を実行してxv6を起動します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
08:32:45.000 [I] net_protocol_register: registered, type=0x0806 (net/net.c:174)
08:32:45.000 [I] net_timer_register: registered: interval={1, 0} (net/net.c:194)
08:32:45.000 [I] net_protocol_register: registered, type=0x0800 (net/net.c:174)
08:32:45.000 [I] net_init: initialized (net/net.c:369)
PCI: 00:00.0: 8086:1237: class: 6.0 (Bridge device) irq: 0
PCI: 00:01.0: 8086:7000: class: 6.1 (Bridge device) irq: 0
PCI: 00:01.1: 8086:7010: class: 1.1 (Storage controller) irq: 0
PCI: 00:01.3: 8086:7113: class: 6.80 (Bridge device) irq: 9
PCI: 00:02.0: 1234:1111: class: 3.0 (Display controller) irq: 0
PCI: 00:03.0: 8086:100e: class: 2.0 (Network controller) irq: 11
PCI function 00:03.0 (8086:100e) enabled
08:32:45.000 [I] net_device_register: registered, dev=net0, type=0x0002 (net/net.c:61)
08:32:45.000 [I] e1000init: initialized, irq=11, addr=52:54:00:12:34:56 (net/platform/xv6/driver/e1000.c:302)
08:32:45.000 [I] ip_route_add: route added: network=192.0.2.0, netmask=255.255.255.0, nexthop=0.0.0.0, iface=192.0.2.2 dev=net0 (net/ip.c:165)
08:32:45.000 [I] ip_iface_register: registered: dev=net0, unicast=192.0.2.2, netmask=255.255.255.0, broadcast=192.0.2.255 (net/ip.c:262)
08:32:45.000 [D] net_run: open all devices... (net/net.c:311)
08:32:45.000 [I] net_device_open: dev=net0, state=up (net/net.c:79)
08:32:45.000 [D] net_run: running... (net/net.c:315)
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
```
</details>

開発環境で別のシェルを開き、`192.0.2.2`に向けて`ping`を実行します。

```
$ ping 192.0.2.2
```

`ping`コマンドを実行しても応答は得られませんが、ARPによるアドレス解決は成功してその後のIPパケットまで受信できていることが確認できます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
08:32:49.000 [D] e1000intr: >>> (net/platform/xv6/driver/e1000.c:231)
08:32:49.000 [D] ether_input_helper: dev=net0, type=0x0806, len=60 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
08:32:49.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0806, len=46 (net/net.c:236)
08:32:49.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0806, len=46 (net/net.c:258)
08:32:49.000 [D] arp_input: dev=net0, len=46 (net/arp.c:236)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 1 (Request)
        sha: 16:2a:af:19:b5:91
        spa: 192.0.2.1
        tha: 00:00:00:00:00:00
        tpa: 192.0.2.2
08:32:49.000 [D] arp_cache_insert: INSERT: pa=192.0.2.1, ha=16:2a:af:19:b5:91 (net/arp.c:173)
08:32:49.000 [D] arp_reply: dev=net0, len=28 (net/arp.c:210)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 2 (Reply)
        sha: 52:54:00:12:34:56
        spa: 192.0.2.2
        tha: 16:2a:af:19:b5:91
        tpa: 192.0.2.1
08:32:49.000 [D] net_device_output: dev=net0, type=0x0806, len=28 (net/net.c:144)
08:32:49.000 [D] ether_transmit_helper: dev=net0, type=0x0806, len=60 (net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0806
08:32:49.000 [D] e1000_write: dev=net0, 60 bytes data transmit (net/platform/xv6/driver/e1000.c:187)
08:32:49.000 [D] ether_input_helper: dev=net0, type=0x0800, len=98 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: 52:54:00:12:34:56
       type: 0x0800
08:32:49.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0800, len=84 (net/net.c:236)
08:32:49.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0800, len=84 (net/net.c:258)
08:32:49.000 [D] ip_input: dev=net0, iface=192.0.2.2, protocol=1, total=84 (net/ip.c:357)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 84 (payload: 64)
         id: 0
     offset: 0x4000 [flags=2, offset=0]
        ttl: 64
   protocol: 1
        sum: 0xb6a5
        src: 192.0.2.1
        dst: 192.0.2.2
08:32:49.000 [D] e1000intr: <<< (net/platform/xv6/driver/e1000.c:250)
```
</details>

## 4.5. ICMPモジュール

自作プロトコルスタックのICMPモジュールを移植します。

#### ✅ ICMPモジュールのコードの追加

ICMPモジュールのコードを追加します。送信メッセージを構築するバッファを動的メモリ確保に変更しています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/icmp.h</span></summary>

```c
#ifndef ICMP_H
#define ICMP_H

#include "platform.h"

#include "ip.h"

#define ICMP_HDR_SIZE 8

#define ICMP_TYPE_ECHOREPLY           0
#define ICMP_TYPE_DEST_UNREACH        3
#define ICMP_TYPE_SOURCE_QUENCH       4
#define ICMP_TYPE_REDIRECT            5
#define ICMP_TYPE_ECHO                8
#define ICMP_TYPE_TIME_EXCEEDED      11
#define ICMP_TYPE_PARAM_PROBLEM      12
#define ICMP_TYPE_TIMESTAMP          13
#define ICMP_TYPE_TIMESTAMPREPLY     14
#define ICMP_TYPE_INFO_REQUEST       15
#define ICMP_TYPE_INFO_REPLY         16

extern int
icmp_output(uint8_t type, uint8_t code, uint32_t values, const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst);

extern int
icmp_init(void);

#endif

```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/icmp.c</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "ip.h"
#include "icmp.h"

#define ICMP_BUFSIZ IP_PAYLOAD_SIZE_MAX

struct icmp_hdr {
    uint8_t type;
    uint8_t code;
    uint16_t sum;
    uint32_t values;
};

struct icmp_echo {
    uint8_t type;
    uint8_t code;
    uint16_t sum;
    uint16_t id;
    uint16_t seq;
};

static char *
icmp_type_ntoa(uint8_t type) {
    switch (type) {
    case ICMP_TYPE_ECHOREPLY:
        return "EchoReply";
    case ICMP_TYPE_DEST_UNREACH:
        return "DestinationUnreachable";
    case ICMP_TYPE_SOURCE_QUENCH:
        return "SourceQuench";
    case ICMP_TYPE_REDIRECT:
        return "Redirect";
    case ICMP_TYPE_ECHO:
        return "Echo";
    case ICMP_TYPE_TIME_EXCEEDED:
        return "TimeExceeded";
    case ICMP_TYPE_PARAM_PROBLEM:
        return "ParameterProblem";
    case ICMP_TYPE_TIMESTAMP:
        return "Timestamp";
    case ICMP_TYPE_TIMESTAMPREPLY:
        return "TimestampReply";
    case ICMP_TYPE_INFO_REQUEST:
        return "InformationRequest";
    case ICMP_TYPE_INFO_REPLY:
        return "InformationReply";
    }
    return "Unknown";
}

static void
icmp_dump(const uint8_t *data, size_t len)
{
    struct icmp_hdr *hdr;
    struct icmp_echo *echo;

    flockfile(stderr);
    hdr = (struct icmp_hdr *)data;
    fprintf(stderr, "       type: %u (%s)\n", hdr->type, icmp_type_ntoa(hdr->type));
    fprintf(stderr, "       code: %u\n", hdr->code);
    fprintf(stderr, "        sum: 0x%04x\n", ntoh16(hdr->sum));
    switch (hdr->type) {
    case ICMP_TYPE_ECHOREPLY:
    case ICMP_TYPE_ECHO:
        echo = (struct icmp_echo *)hdr;
        fprintf(stderr, "         id: %u\n", ntoh16(echo->id));
        fprintf(stderr, "        seq: %u\n", ntoh16(echo->seq));
        break;
    default:
        fprintf(stderr, "     values: 0x%08x\n", ntoh32(hdr->values));
        break;
    }
#ifdef HEXDUMP
    hexdump(stderr, data, len);
#endif
    funlockfile(stderr);
}

void
icmp_input(const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst, struct ip_iface *iface)
{
    struct icmp_hdr *hdr;
    char addr1[IP_ADDR_STR_LEN];
    char addr2[IP_ADDR_STR_LEN];

    if (len < sizeof(*hdr)) {
        errorf("too short");
        return;
    }
    hdr = (struct icmp_hdr *)data;
    if (cksum16((uint16_t *)data, len, 0) != 0) {
        errorf("checksum error, sum=0x%04x, verify=0x%04x", ntoh16(hdr->sum), ntoh16(cksum16((uint16_t *)data, len, -hdr->sum)));
        return;
    }
    debugf("%s => %s, len=%zu", ip_addr_ntop(src, addr1, sizeof(addr1)), ip_addr_ntop(dst, addr2, sizeof(addr2)), len);
    icmp_dump(data, len);
    switch (hdr->type) {
    case ICMP_TYPE_ECHO:
        /* Responds with the address of the received interface. */
        icmp_output(ICMP_TYPE_ECHOREPLY, hdr->code, hdr->values, (uint8_t *)(hdr + 1), len - sizeof(*hdr), iface->unicast, src);
        break;
    default:
        /* ignore */
        break;
    }
}

int
icmp_output(uint8_t type, uint8_t code, uint32_t values, const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst)
{
    uint8_t *buf;
    struct icmp_hdr *hdr;
    size_t msg_len;
    char addr1[IP_ADDR_STR_LEN];
    char addr2[IP_ADDR_STR_LEN];
    int ret;

    buf = memory_alloc(ICMP_BUFSIZ);
    if (!buf) {
        errorf("memory_alloc() failure");
        return -1;
    }
    hdr = (struct icmp_hdr *)buf;
    hdr->type = type;
    hdr->code = code;
    hdr->sum = 0;
    hdr->values = values;
    memcpy(hdr+1, data, len);
    msg_len = sizeof(*hdr) + len;
    hdr->sum = cksum16((uint16_t *)hdr, msg_len, 0);
    debugf("%s => %s, len=%zu", ip_addr_ntop(src, addr1, sizeof(addr1)), ip_addr_ntop(dst, addr2, sizeof(addr2)), msg_len);
    icmp_dump(buf, msg_len);
    ret = ip_output(IP_PROTOCOL_ICMP, buf, msg_len, src, dst);
    memory_free(buf);
    return ret;
}

int
icmp_init(void)
{
    if (ip_protocol_register(IP_PROTOCOL_ICMP, icmp_input) == -1) {
        errorf("ip_protocol_register() failure");
        return -1;
    }
    return 0;
}
```
</details>

#### ✅ 初期化関数の呼び出し

`net_init()`からICMPモジュールの初期化関数を呼び出すようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/net.c</span></summary>

```diff
...

 #include "arp.h"
 #include "ip.h"
+#include "icmp.h"

 int
 net_init(void)
 {
     if (intr_init() == -1) {
         errorf("intr_init() failure");
         return -1;
     }
     if (arp_init() == -1) {
         errorf("arp_init() failure");
         return -1;
     }
     if (ip_init() == -1) {
         errorf("ip_init() failure");
         return -1;
     }
+    if (icmp_init() == -1) {
+        errorf("icmp_init() failure");
+        return -1;
+    }
     infof("initialized");
     return 0;
 }
```
</details>

#### ✅ Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
...
 	net/platform/xv6/std.o\
 	net/platform/xv6/driver/e1000.o\
 	net/util.o\
 	net/net.o\
 	net/ether.o\
 	net/arp.o\
 	net/ip.o\
+	net/icmp.o\

```
</details>

#### ✅ 動作確認

再ビルドした後、`make qemu-nox`を実行してxv6を起動します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
08:45:33.000 [I] net_protocol_register: registered, type=0x0806 (net/net.c:174)
08:45:33.000 [I] net_timer_register: registered: interval={1, 0} (net/net.c:194)
08:45:33.000 [I] net_protocol_register: registered, type=0x0800 (net/net.c:174)
08:45:33.000 [I] ip_protocol_register: registered, type=1 (net/ip.c:303)
08:45:33.000 [I] net_init: initialized (net/net.c:369)
PCI: 00:00.0: 8086:1237: class: 6.0 (Bridge device) irq: 0
PCI: 00:01.0: 8086:7000: class: 6.1 (Bridge device) irq: 0
PCI: 00:01.1: 8086:7010: class: 1.1 (Storage controller) irq: 0
PCI: 00:01.3: 8086:7113: class: 6.80 (Bridge device) irq: 9
PCI: 00:02.0: 1234:1111: class: 3.0 (Display controller) irq: 0
PCI: 00:03.0: 8086:100e: class: 2.0 (Network controller) irq: 11
PCI function 00:03.0 (8086:100e) enabled
08:45:33.000 [I] net_device_register: registered, dev=net0, type=0x0002 (net/net.c:61)
08:45:33.000 [I] e1000init: initialized, irq=11, addr=52:54:00:12:34:56 (net/platform/xv6/driver/e1000.c:302)
08:45:33.000 [I] ip_route_add: route added: network=192.0.2.0, netmask=255.255.255.0, nexthop=0.0.0.0, iface=192.0.2.2 dev=net0 (net/ip.c:165)
08:45:33.000 [I] ip_iface_register: registered: dev=net0, unicast=192.0.2.2, netmask=255.255.255.0, broadcast=192.0.2.255 (net/ip.c:262)
08:45:33.000 [D] net_run: open all devices... (net/net.c:311)
08:45:33.000 [I] net_device_open: dev=net0, state=up (net/net.c:79)
08:45:33.000 [D] net_run: running... (net/net.c:315)
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
```
</details>

先ほどと同様に、`192.0.2.2`に向けて`ping`を実行します。

```
$ ping 192.0.2.2  
PING 192.0.2.2 (192.0.2.2) 56(84) bytes of data.
64 bytes from 192.0.2.2: icmp_seq=1 ttl=255 time=43.2 ms
64 bytes from 192.0.2.2: icmp_seq=2 ttl=255 time=24.1 ms
64 bytes from 192.0.2.2: icmp_seq=3 ttl=255 time=24.0 ms
```

今回は応答が得られるはずです。ログメッセージからもICMPのEchoReplyメッセージを送信していることが確認できます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
08:45:35.000 [D] e1000intr: >>> (net/platform/xv6/driver/e1000.c:231)
08:45:35.000 [D] ether_input_helper: dev=net0, type=0x0806, len=60 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
08:45:35.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0806, len=46 (net/net.c:236)
08:45:35.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0806, len=46 (net/net.c:258)
08:45:35.000 [D] arp_input: dev=net0, len=46 (net/arp.c:236)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 1 (Request)
        sha: 16:2a:af:19:b5:91
        spa: 192.0.2.1
        tha: 00:00:00:00:00:00
        tpa: 192.0.2.2
08:45:35.000 [D] arp_cache_insert: INSERT: pa=192.0.2.1, ha=16:2a:af:19:b5:91 (net/arp.c:173)
08:45:35.000 [D] arp_reply: dev=net0, len=28 (net/arp.c:210)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 2 (Reply)
        sha: 52:54:00:12:34:56
        spa: 192.0.2.2
        tha: 16:2a:af:19:b5:91
        tpa: 192.0.2.1
08:45:35.000 [D] net_device_output: dev=net0, type=0x0806, len=28 (net/net.c:144)
08:45:35.000 [D] ether_transmit_helper: dev=net0, type=0x0806, len=60 (net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0806
08:45:35.000 [D] e1000_write: dev=net0, 60 bytes data transmit (net/platform/xv6/driver/e1000.c:187)
08:45:35.000 [D] ether_input_helper: dev=net0, type=0x0800, len=98 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: 52:54:00:12:34:56
       type: 0x0800
08:45:35.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0800, len=84 (net/net.c:236)
08:45:35.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0800, len=84 (net/net.c:258)
08:45:35.000 [D] ip_input: dev=net0, iface=192.0.2.2, protocol=1, total=84 (net/ip.c:357)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 84 (payload: 64)
         id: 0
     offset: 0x4000 [flags=2, offset=0]
        ttl: 64
   protocol: 1
        sum: 0xb6a5
        src: 192.0.2.1
        dst: 192.0.2.2
08:45:35.000 [D] icmp_input: 192.0.2.1 => 192.0.2.2, len=64 (net/icmp.c:97)
       type: 8 (Echo)
       code: 0
        sum: 0x5de4
         id: 25
        seq: 1
08:45:35.000 [D] icmp_output: 192.0.2.2 => 192.0.2.1, len=64 (net/icmp.c:133)
       type: 0 (EchoReply)
       code: 0
        sum: 0x65e4
         id: 25
        seq: 1
08:45:35.000 [D] ip_output_core: dev=net0, dst=192.0.2.1, protocol=1, len=84 (net/ip.c:416)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 84 (payload: 64)
         id: 128
     offset: 0x0000 [flags=0, offset=0]
        ttl: 255
   protocol: 1
        sum: 0x3725
        src: 192.0.2.2
        dst: 192.0.2.1
08:45:35.000 [D] arp_resolve: resolved, pa=192.0.2.1, ha=16:2a:af:19:b5:91 (net/arp.c:298)
08:45:35.000 [D] net_device_output: dev=net0, type=0x0800, len=84 (net/net.c:144)
08:45:35.000 [D] ether_transmit_helper: dev=net0, type=0x0800, len=98 (net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0800
08:45:35.000 [D] e1000_write: dev=net0, 98 bytes data transmit (net/platform/xv6/driver/e1000.c:187)
08:45:35.000 [D] e1000intr: <<< (net/platform/xv6/driver/e1000.c:250)
...
```
</details>

## 4.6. UDPモジュール

自作プロトコルスタックのUDPモジュールを移植します。

#### ✅ UDPモジュールのコードの追加

UDPモジュールのコードを追加します。送信パケットを構築するバッファを動的メモリ確保に変更しています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/udp.h</span></summary>

```c
#ifndef UDP_H
#define UDP_H

#include "platform.h"

#include "ip.h"

extern ssize_t
udp_output(struct ip_endpoint *src, struct ip_endpoint *dst, const uint8_t *buf, size_t len);

extern int
udp_init(void);

extern int
udp_open(void);
extern int
udp_close(int id);
extern int
udp_bind(int index, struct ip_endpoint *local);
extern ssize_t
udp_sendto(int id, uint8_t *buf, size_t len, struct ip_endpoint *foreign);
extern ssize_t
udp_recvfrom(int id, uint8_t *buf, size_t size, struct ip_endpoint *foreign);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/udp.c</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "ip.h"
#include "udp.h"

#define UDP_PCB_SIZE 16

#define UDP_PCB_STATE_FREE    0
#define UDP_PCB_STATE_OPEN    1
#define UDP_PCB_STATE_CLOSING 2

/* see https://tools.ietf.org/html/rfc6335 */
#define UDP_SOURCE_PORT_MIN 49152
#define UDP_SOURCE_PORT_MAX 65535

struct pseudo_hdr {
    uint32_t src;
    uint32_t dst;
    uint8_t zero;
    uint8_t protocol;
    uint16_t len;
};

struct udp_hdr {
    uint16_t src;
    uint16_t dst;
    uint16_t len;
    uint16_t sum;
};

struct udp_pcb {
    int state;
    struct ip_endpoint local;
    struct queue_head queue; /* receive queue */
    struct sched_ctx ctx;
};

struct udp_queue_entry {
    struct ip_endpoint foreign;
    uint16_t len;
    uint8_t data[];
};

static mutex_t mutex = MUTEX_INITIALIZER;
static struct udp_pcb pcbs[UDP_PCB_SIZE];

static void
udp_dump(const uint8_t *data, size_t len)
{
    struct udp_hdr *hdr;

    flockfile(stderr);
    hdr = (struct udp_hdr *)data;
    fprintf(stderr, "        src: %u\n", ntoh16(hdr->src));
    fprintf(stderr, "        dst: %u\n", ntoh16(hdr->dst));
    fprintf(stderr, "        len: %u\n", ntoh16(hdr->len));
    fprintf(stderr, "        sum: 0x%04x\n", ntoh16(hdr->sum));
#ifdef HEXDUMP
    hexdump(stderr, data, len);
#endif
    funlockfile(stderr);
}

/*
 * UDP Protocol Control Block (PCB)
 *
 * NOTE: UDP PCB functions must be called after mutex locked
 */

static struct udp_pcb *
udp_pcb_alloc(void)
{
    struct udp_pcb *pcb;

    for (pcb = pcbs; pcb < tailof(pcbs); pcb++) {
        if (pcb->state == UDP_PCB_STATE_FREE) {
            pcb->state = UDP_PCB_STATE_OPEN;
            sched_ctx_init(&pcb->ctx);
            return pcb;
        }
    }
    return NULL;
}

static void
udp_pcb_release(struct udp_pcb *pcb)
{
    struct queue_entry *entry;

    pcb->state = UDP_PCB_STATE_CLOSING;
    if (sched_ctx_destroy(&pcb->ctx) == -1) {
        sched_wakeup(&pcb->ctx);
        return;
    }
    pcb->state = UDP_PCB_STATE_FREE;
    pcb->local.addr = IP_ADDR_ANY;
    pcb->local.port = 0;
    while (1) { /* Discard the entries in the queue. */
        entry = queue_pop(&pcb->queue);
        if (!entry) {
            break;
        }
        memory_free(entry);
    }
}

static struct udp_pcb *
udp_pcb_select(ip_addr_t addr, uint16_t port)
{
    struct udp_pcb *pcb;

    for (pcb = pcbs; pcb < tailof(pcbs); pcb++) {
        if (pcb->state == UDP_PCB_STATE_OPEN) {
            if ((pcb->local.addr == IP_ADDR_ANY || pcb->local.addr == addr) && pcb->local.port == port) {
                return pcb;
            }
        }
    }
    return NULL;
}

static struct udp_pcb *
udp_pcb_get(int id)
{
    struct udp_pcb *pcb;

    if (id < 0 || id >= (int)countof(pcbs)) {
        /* out of range */
        return NULL;
    }
    pcb = &pcbs[id];
    if (pcb->state != UDP_PCB_STATE_OPEN) {
        return NULL;
    }
    return pcb;
}

static int
udp_pcb_id(struct udp_pcb *pcb)
{
    return indexof(pcbs, pcb);
}

static void
udp_input(const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst, struct ip_iface *iface)
{
    struct pseudo_hdr pseudo;
    uint16_t psum = 0;
    struct udp_hdr *hdr;
    char addr1[IP_ADDR_STR_LEN];
    char addr2[IP_ADDR_STR_LEN];
    struct udp_pcb *pcb;
    struct udp_queue_entry *entry;

    if (len < sizeof(*hdr)) {
        errorf("too short");
        return;
    }
    hdr = (struct udp_hdr *)data;
    if (len != ntoh16(hdr->len)) { /* just to make sure */
        errorf("length error: len=%zu, hdr->len=%u", len, ntoh16(hdr->len));
        return;
    }
    pseudo.src = src;
    pseudo.dst = dst;
    pseudo.zero = 0;
    pseudo.protocol = IP_PROTOCOL_UDP;
    pseudo.len = hton16(len);
    psum = ~cksum16((uint16_t *)&pseudo, sizeof(pseudo), 0);
    if (cksum16((uint16_t *)hdr, len, psum) != 0) {
        errorf("checksum error: sum=0x%04x, verify=0x%04x", ntoh16(hdr->sum), ntoh16(cksum16((uint16_t *)hdr, len, -hdr->sum + psum)));
        return;
    }
    debugf("%s:%d => %s:%d, len=%zu (payload=%zu)",
        ip_addr_ntop(src, addr1, sizeof(addr1)), ntoh16(hdr->src),
        ip_addr_ntop(dst, addr2, sizeof(addr2)), ntoh16(hdr->dst),
        len, len - sizeof(*hdr));
    udp_dump(data, len);
    mutex_lock(&mutex);
    pcb = udp_pcb_select(dst, hdr->dst);
    if (!pcb) {
        /* port is not in use */
        mutex_unlock(&mutex);
        return;
    }
    entry = memory_alloc(sizeof(*entry) + (len - sizeof(*hdr)));
    if (!entry) {
        mutex_unlock(&mutex);
        errorf("memory_alloc() failure");
        return;
    }
    entry->foreign.addr = src;
    entry->foreign.port = hdr->src;
    entry->len = len - sizeof(*hdr);
    memcpy(entry->data, hdr+1, entry->len);
    if (!queue_push(&pcb->queue, entry)) {
        mutex_unlock(&mutex);
        errorf("queue_push() failure");
        return;
    }
    debugf("queue pushed: id=%d, num=%d", udp_pcb_id(pcb), pcb->queue.num);
    sched_wakeup(&pcb->ctx);
    mutex_unlock(&mutex);
}

ssize_t
udp_output(struct ip_endpoint *src, struct ip_endpoint *dst, const  uint8_t *data, size_t len)
{
    uint8_t *buf;
    struct udp_hdr *hdr;
    struct pseudo_hdr pseudo;
    uint16_t total, psum = 0;
    char ep1[IP_ENDPOINT_STR_LEN];
    char ep2[IP_ENDPOINT_STR_LEN];

    buf = memory_alloc(IP_PAYLOAD_SIZE_MAX);
    if (!buf) {
        errorf("memory_alloc() failure");
        return -1;
    }
    if (len > IP_PAYLOAD_SIZE_MAX - sizeof(*hdr)) {
        errorf("too long");
        memory_free(buf);
        return -1;
    }
    hdr = (struct udp_hdr *)buf;
    hdr->src = src->port;
    hdr->dst = dst->port;
    total = sizeof(*hdr) + len;
    hdr->len = hton16(total);
    hdr->sum = 0;
    memcpy(hdr + 1, data, len);
    pseudo.src = src->addr;
    pseudo.dst = dst->addr;
    pseudo.zero = 0;
    pseudo.protocol = IP_PROTOCOL_UDP;
    pseudo.len = hton16(total);
    psum = ~cksum16((uint16_t *)&pseudo, sizeof(pseudo), 0);
    hdr->sum = cksum16((uint16_t *)hdr, total, psum);
    debugf("%s => %s, len=%zu (payload=%zu)",
        ip_endpoint_ntop(src, ep1, sizeof(ep1)), ip_endpoint_ntop(dst, ep2, sizeof(ep2)), total, len);
    udp_dump((uint8_t *)hdr, total);
    if (ip_output(IP_PROTOCOL_UDP, (uint8_t *)hdr, total, src->addr, dst->addr) == -1) {
        errorf("ip_output() failure");
        memory_free(buf);
        return -1;
    }
    memory_free(buf);
    return len;
}

static void
event_handler(void *arg)
{
    struct udp_pcb *pcb;

    (void)arg;
    mutex_lock(&mutex);
    for (pcb = pcbs; pcb < tailof(pcbs); pcb++) {
        if (pcb->state == UDP_PCB_STATE_OPEN) {
            sched_interrupt(&pcb->ctx);
        }
    }
    mutex_unlock(&mutex);
}

int
udp_init(void)
{
    if (ip_protocol_register(IP_PROTOCOL_UDP, udp_input) == -1) {
        errorf("ip_protocol_register() failure");
        return -1;
    }
    net_event_subscribe(event_handler, NULL);
    return 0;
}

/*
 * UDP User Commands
 */

int
udp_open(void)
{
    struct udp_pcb *pcb;
    int id;

    mutex_lock(&mutex);
    pcb = udp_pcb_alloc();
    if (!pcb) {
        errorf("udp_pcb_alloc() failure");
        mutex_unlock(&mutex);
        return -1;
    }
    id = udp_pcb_id(pcb);
    mutex_unlock(&mutex);
    return id;
}

int
udp_close(int id)
{
    struct udp_pcb *pcb;

    mutex_lock(&mutex);
    pcb = udp_pcb_get(id);
    if (!pcb) {
        errorf("pcb not found, id=%d", id);
        mutex_unlock(&mutex);
        return -1;
    }
    udp_pcb_release(pcb);
    mutex_unlock(&mutex);
    return 0;
}

int
udp_bind(int id, struct ip_endpoint *local)
{
    struct udp_pcb *pcb, *exist;
    char ep1[IP_ENDPOINT_STR_LEN];
    char ep2[IP_ENDPOINT_STR_LEN];

    mutex_lock(&mutex);
    pcb = udp_pcb_get(id);
    if (!pcb) {
        errorf("pcb not found, id=%d", id);
        mutex_unlock(&mutex);
        return -1;
    }
    exist = udp_pcb_select(local->addr, local->port);
    if (exist) {
        errorf("already in use, id=%d, want=%s, exist=%s",
            id, ip_endpoint_ntop(local, ep1, sizeof(ep1)), ip_endpoint_ntop(&exist->local, ep2, sizeof(ep2)));
        mutex_unlock(&mutex);
        return -1;
    }
    pcb->local = *local;
    debugf("bound, id=%d, local=%s", id, ip_endpoint_ntop(&pcb->local, ep1, sizeof(ep1)));
    mutex_unlock(&mutex);
    return 0;
}

ssize_t
udp_sendto(int id, uint8_t *data, size_t len, struct ip_endpoint *foreign)
{
    struct udp_pcb *pcb;
    struct ip_endpoint local;
    struct ip_iface *iface;
    char addr[IP_ADDR_STR_LEN];
    uint32_t p;

    mutex_lock(&mutex);
    pcb = udp_pcb_get(id);
    if (!pcb) {
        errorf("pcb not found, id=%d", id);
        mutex_unlock(&mutex);
        return -1;
    }
    local.addr = pcb->local.addr;
    if (local.addr == IP_ADDR_ANY) {
        iface = ip_route_get_iface(foreign->addr);
        if (!iface) {
            errorf("iface not found that can reach foreign address, addr=%s",
                ip_addr_ntop(foreign->addr, addr, sizeof(addr)));
            mutex_unlock(&mutex);
            return -1;
        }
        local.addr = iface->unicast;
        debugf("select local address, addr=%s", ip_addr_ntop(local.addr, addr, sizeof(addr)));
    }
    if (!pcb->local.port) {
        for (p = UDP_SOURCE_PORT_MIN; p <= UDP_SOURCE_PORT_MAX; p++) {
            if (!udp_pcb_select(local.addr, hton16(p))) {
                pcb->local.port = hton16(p);
                debugf("dinamic assign local port, port=%d", p);
                break;
            }
        }
        if (!pcb->local.port) {
            debugf("failed to dinamic assign local port, addr=%s", ip_addr_ntop(local.addr, addr, sizeof(addr)));
            mutex_unlock(&mutex);
            return -1;
        }
    }
    local.port = pcb->local.port;
    mutex_unlock(&mutex);
    return udp_output(&local, foreign, data, len);
}

ssize_t
udp_recvfrom(int id, uint8_t *buf, size_t size, struct ip_endpoint *foreign)
{
    struct udp_pcb *pcb;
    struct udp_queue_entry *entry;
    ssize_t len;
    int err;

    mutex_lock(&mutex);
    pcb = udp_pcb_get(id);
    if (!pcb) {
        errorf("pcb not found, id=%d", id);
        mutex_unlock(&mutex);
        return -1;
    }
    while (1) {
        entry = queue_pop(&pcb->queue);
        if (entry) {
            break;
        }
        /* Wait to be woken up by sched_wakeup() or shced_interrupt() */
        err = sched_sleep(&pcb->ctx, &mutex, NULL);
        if (err) {
            debugf("interrupted");
            mutex_unlock(&mutex);
            errno = EINTR;
            return -1;
        }
        if (pcb->state == UDP_PCB_STATE_CLOSING) {
            debugf("closed");
            udp_pcb_release(pcb);
            mutex_unlock(&mutex);
            return -1;
        }
    }
    mutex_unlock(&mutex);
    if (foreign) {
        *foreign = entry->foreign;
    }
    len = MIN(size, entry->len); /* truncate */
    memcpy(buf, entry->data, len);
    memory_free(entry);
    return len;
}
```
</details>

#### ✅ 環境依存のタスク制御

UDPモジュールではタスクの休止と起床の操作を行うので、xv6環境でのタスク制御のコードを追加します。

xv6では`sleep()`と`wakeup()`によてタスクを休止・起床できます。`sleep()`と`wakeup()`は、休止と起床の対応付のために任意のポインタ（xv6ではチャネルと呼んでいる）を受け取りますが、これはアドレスの一致確認のみに利用されるのでどのような資源でも指定可能です。また、`sleep()`を呼び出す際にはあらかじめスピンロックを獲得しておく必要があります。タイムアウト指定は利用していないので無視するようにしています。

`pthread_cond`の場合とほとんど同じように実装できています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/platform.h</span></summary>

```diff
...

/*
 * Scheduler
 */

+struct sched_ctx {
+    int interrupted;
+    int wc; /* wait count */
+};
+
+#define SCHED_CTX_INITIALIZER {0, 0}
+
+static inline int
+sched_ctx_init(struct sched_ctx *ctx)
+{
+    ctx->interrupted = 0;
+    ctx->wc = 0;
+    return 0;
+}
+
+static inline int
+sched_ctx_destroy(struct sched_ctx *ctx)
+{
+    if (ctx->wc) {
+        return -1;
+    }
+    return 0;
+}
+
+static inline int
+sched_sleep(struct sched_ctx *ctx, mutex_t *mutex, const struct timespec *abstime)
+{
+    (void)abstime;
+    if (ctx->interrupted) {
+        errno = EINTR;
+        return -1;
+    }
+    ctx->wc++;
+    sleep(ctx, mutex);
+    ctx->wc--;
+    if (ctx->interrupted) {
+        if (!ctx->wc) {
+            ctx->interrupted = 0;
+        }
+        errno = EINTR;
+        return -1;
+    }
+    return 0;
+}
+
+static inline int
+sched_wakeup(struct sched_ctx *ctx)
+{
+    wakeup(ctx);
+    return 0;
+}
+
+static inline int
+sched_interrupt(struct sched_ctx *ctx)
+{
+    ctx->interrupted = 1;
+    wakeup(ctx);
+    return 0;
+}

#endif
```
</details>

#### ✅ 初期化関数の呼び出し

`net_init()`からUDPモジュールの初期化関数を呼び出すようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/net.c</span></summary>

```diff
...

 #include "arp.h"
 #include "ip.h"
 #include "icmp.h"
+#include "udp.h"

 int
 net_init(void)
 {
     if (intr_init() == -1) {
         errorf("intr_init() failure");
         return -1;
     }
     if (arp_init() == -1) {
         errorf("arp_init() failure");
         return -1;
     }
     if (ip_init() == -1) {
         errorf("ip_init() failure");
         return -1;
     }
     if (icmp_init() == -1) {
         errorf("icmp_init() failure");
         return -1;
     }
+    if (udp_init() == -1) {
+        errorf("udp_init() failure");
+        return -1;
+    }
     infof("initialized");
     return 0;
 }
```
</details>

#### ✅ Makefileの修正

ソースファイルを追加したので`Makefile`を修正します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
...
 	net/platform/xv6/std.o\
 	net/platform/xv6/driver/e1000.o\
 	net/util.o\
 	net/net.o\
 	net/ether.o\
 	net/arp.o\
 	net/ip.o\
 	net/icmp.o\
+	net/udp.o\

```
</details>

#### ✅ 動作確認

再ビルドした後、`make qemu-nox`を実行してxv6を起動します。

プロトコル番号`17`のプロトコル（UDP）がIPモジュールに登録されていることが確認できます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
09:33:35.000 [I] net_protocol_register: registered, type=0x0806 (net/net.c:176)
09:33:35.000 [I] net_timer_register: registered: interval={1, 0} (net/net.c:196)
09:33:35.000 [I] net_protocol_register: registered, type=0x0800 (net/net.c:176)
09:33:35.000 [I] ip_protocol_register: registered, type=1 (net/ip.c:303)
09:33:35.000 [I] ip_protocol_register: registered, type=17 (net/ip.c:303)
09:33:35.000 [I] net_init: initialized (net/net.c:371)
PCI: 00:00.0: 8086:1237: class: 6.0 (Bridge device) irq: 0
PCI: 00:01.0: 8086:7000: class: 6.1 (Bridge device) irq: 0
PCI: 00:01.1: 8086:7010: class: 1.1 (Storage controller) irq: 0
PCI: 00:01.3: 8086:7113: class: 6.80 (Bridge device) irq: 9
PCI: 00:02.0: 1234:1111: class: 3.0 (Display controller) irq: 0
PCI: 00:03.0: 8086:100e: class: 2.0 (Network controller) irq: 11
PCI function 00:03.0 (8086:100e) enabled
09:33:35.000 [I] net_device_register: registered, dev=net0, type=0x0002 (net/net.c:63)
09:33:35.000 [I] e1000init: initialized, irq=11, addr=52:54:00:12:34:56 (net/platform/xv6/driver/e1000.c:302)
09:33:35.000 [I] ip_route_add: route added: network=192.0.2.0, netmask=255.255.255.0, nexthop=0.0.0.0, iface=192.0.2.2 dev=net0 (net/ip.c:165)
09:33:35.000 [I] ip_iface_register: registered: dev=net0, unicast=192.0.2.2, netmask=255.255.255.0, broadcast=192.0.2.255 (net/ip.c:262)
09:33:35.000 [D] net_run: open all devices... (net/net.c:313)
09:33:35.000 [I] net_device_open: dev=net0, state=up (net/net.c:81)
09:33:35.000 [D] net_run: running... (net/net.c:317)
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
```
</details>

開発環境で別のシェルを開き、`nc`コマンドを実行します。

宛先は`192.0.2.2`の`7`番ポートで、UDPメッセージを送信するために`-u`オプションを指定します。`

```
$ nc -u 192.0.2.2 7
hoge
```

nc`コマンドが起動したら適当なテキスト入力してエンターキーを押します。応答はありませんが、xv6側のログを確認するとUDPモジュールまでUDPのパケットが受け渡されています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">ログメッセージ</span></summary>

```
09:33:37.000 [D] e1000intr: >>> (net/platform/xv6/driver/e1000.c:231)
09:33:37.000 [D] ether_input_helper: dev=net0, type=0x0806, len=60 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
09:33:37.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0806, len=46 (net/net.c:238)
09:33:37.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0806, len=46 (net/net.c:260)
09:33:37.000 [D] arp_input: dev=net0, len=46 (net/arp.c:236)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 1 (Request)
        sha: 16:2a:af:19:b5:91
        spa: 192.0.2.1
        tha: 00:00:00:00:00:00
        tpa: 192.0.2.2
09:33:37.000 [D] arp_cache_insert: INSERT: pa=192.0.2.1, ha=16:2a:af:19:b5:91 (net/arp.c:173)
09:33:37.000 [D] arp_reply: dev=net0, len=28 (net/arp.c:210)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 2 (Reply)
        sha: 52:54:00:12:34:56
        spa: 192.0.2.2
        tha: 16:2a:af:19:b5:91
        tpa: 192.0.2.1
09:33:37.000 [D] net_device_output: dev=net0, type=0x0806, len=28 (net/net.c:146)
09:33:37.000 [D] ether_transmit_helper: dev=net0, type=0x0806, len=60 (net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0806
09:33:37.000 [D] e1000_write: dev=net0, 60 bytes data transmit (net/platform/xv6/driver/e1000.c:187)
09:33:37.000 [D] ether_input_helper: dev=net0, type=0x0800, len=60 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: 52:54:00:12:34:56
       type: 0x0800
09:33:37.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0800, len=46 (net/net.c:238)
09:33:37.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0800, len=46 (net/net.c:260)
09:33:37.000 [D] ip_input: dev=net0, iface=192.0.2.2, protocol=17, total=33 (net/ip.c:357)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 33 (payload: 13)
         id: 49108
     offset: 0x4000 [flags=2, offset=0]
        ttl: 64
   protocol: 17
        sum: 0xf6f3
        src: 192.0.2.1
        dst: 192.0.2.2
09:33:37.000 [D] udp_input: 192.0.2.1:39403 => 192.0.2.2:7, len=13 (payload=5) (net/udp.c:183)
        src: 39403
        dst: 7
        len: 13
        sum: 0x0809
09:33:37.000 [D] e1000intr: <<< (net/platform/xv6/driver/e1000.c:250)
```
</details>

## 4.7. TCPモジュール

自作プロトコルスタックのTCPモジュールを移植します。

#### ✅ TCPモジュールのコードの追加

TCPモジュールのコードを追加します。送信パケットを構築するバッファを動的メモリ確保に変更しています。

また、開発ドキュメントのコードでは1箇所だけ`pthread_mutex_unlock()`を直接呼び出しているところがあったため`mutex_unlock()`に置き換えています。※ `tcp_open_rfc793()`の最後

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/tcp.h</span></summary>

```c
#ifndef TCP_H
#define TCP_H

#include "platform.h"

#include "ip.h"

extern int
tcp_init(void);

extern int
tcp_open_rfc793(struct ip_endpoint *local, struct ip_endpoint *foreign, int active);
extern int
tcp_close(int id);
extern ssize_t
tcp_send(int id, uint8_t *data, size_t len);
extern ssize_t
tcp_receive(int id, uint8_t *buf, size_t size);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/tcp.c</span></summary>

```c
#include "platform.h"

#include "util.h"
#include "ip.h"
#include "tcp.h"

#define TCP_FLG_FIN 0x01
#define TCP_FLG_SYN 0x02
#define TCP_FLG_RST 0x04
#define TCP_FLG_PSH 0x08
#define TCP_FLG_ACK 0x10
#define TCP_FLG_URG 0x20

#define TCP_FLG_IS(x, y) ((x & 0x3f) == (y))
#define TCP_FLG_ISSET(x, y) ((x & 0x3f) & (y) ? 1 : 0)

#define TCP_PCB_SIZE 16

#define TCP_PCB_STATE_FREE         0
#define TCP_PCB_STATE_CLOSED       1
#define TCP_PCB_STATE_LISTEN       2
#define TCP_PCB_STATE_SYN_SENT     3
#define TCP_PCB_STATE_SYN_RECEIVED 4
#define TCP_PCB_STATE_ESTABLISHED  5
#define TCP_PCB_STATE_FIN_WAIT1    6
#define TCP_PCB_STATE_FIN_WAIT2    7
#define TCP_PCB_STATE_CLOSING      8
#define TCP_PCB_STATE_TIME_WAIT    9
#define TCP_PCB_STATE_CLOSE_WAIT  10
#define TCP_PCB_STATE_LAST_ACK    11

#define TCP_DEFAULT_RTO 200000 /* micro seconds */
#define TCP_RETRANSMIT_DEADLINE 12 /* seconds */

struct pseudo_hdr {
    uint32_t src;
    uint32_t dst;
    uint8_t zero;
    uint8_t protocol;
    uint16_t len;
};

struct tcp_hdr {
    uint16_t src;
    uint16_t dst;
    uint32_t seq;
    uint32_t ack;
    uint8_t off;
    uint8_t flg;
    uint16_t wnd;
    uint16_t sum;
    uint16_t up;
};

struct tcp_segment_info {
    uint32_t seq;
    uint32_t ack;
    uint16_t len;
    uint16_t wnd;
    uint16_t up;
};

struct tcp_pcb {
    int state;
    struct ip_endpoint local;
    struct ip_endpoint foreign;
    struct {
        uint32_t nxt;
        uint32_t una;
        uint16_t wnd;
        uint16_t up;
        uint32_t wl1;
        uint32_t wl2;
    } snd;
    uint32_t iss;
    struct {
        uint32_t nxt;
        uint16_t wnd;
        uint16_t up;
    } rcv;
    uint32_t irs;
    uint16_t mtu;
    uint16_t mss;
    uint8_t buf[65535]; /* receive buffer */
    struct sched_ctx ctx;
    struct queue_head queue; /* retransmit queue */
};

struct tcp_queue_entry {
    struct timeval first;
    struct timeval last;
    unsigned int rto; /* micro seconds */
    uint32_t seq;
    uint8_t flg;
    size_t len;
    uint8_t data[];
};

static mutex_t mutex = MUTEX_INITIALIZER;
static struct tcp_pcb pcbs[TCP_PCB_SIZE];

static char *
tcp_flg_ntoa(uint8_t flg)
{
    static char str[9];

    snprintf(str, sizeof(str), "--%c%c%c%c%c%c",
        TCP_FLG_ISSET(flg, TCP_FLG_URG) ? 'U' : '-',
        TCP_FLG_ISSET(flg, TCP_FLG_ACK) ? 'A' : '-',
        TCP_FLG_ISSET(flg, TCP_FLG_PSH) ? 'P' : '-',
        TCP_FLG_ISSET(flg, TCP_FLG_RST) ? 'R' : '-',
        TCP_FLG_ISSET(flg, TCP_FLG_SYN) ? 'S' : '-',
        TCP_FLG_ISSET(flg, TCP_FLG_FIN) ? 'F' : '-');
    return str;
}

static void
tcp_dump(const uint8_t *data, size_t len)
{
    struct tcp_hdr *hdr;

    flockfile(stderr);
    hdr = (struct tcp_hdr *)data;
    fprintf(stderr, "        src: %u\n", ntoh16(hdr->src));
    fprintf(stderr, "        dst: %u\n", ntoh16(hdr->dst));
    fprintf(stderr, "        seq: %u\n", ntoh32(hdr->seq));
    fprintf(stderr, "        ack: %u\n", ntoh32(hdr->ack));
    fprintf(stderr, "        off: 0x%02x (%d)\n", hdr->off, (hdr->off >> 4) << 2);
    fprintf(stderr, "        flg: 0x%02x (%s)\n", hdr->flg, tcp_flg_ntoa(hdr->flg));
    fprintf(stderr, "        wnd: %u\n", ntoh16(hdr->wnd));
    fprintf(stderr, "        sum: 0x%04x\n", ntoh16(hdr->sum));
    fprintf(stderr, "         up: %u\n", ntoh16(hdr->up));
#ifdef HEXDUMP
    hexdump(stderr, data, len);
#endif
    funlockfile(stderr);
}

/*
 * TCP Protocol Control Block (PCB)
 *
 * NOTE: TCP PCB functions must be called after mutex locked
 */

static struct tcp_pcb *
tcp_pcb_alloc(void)
{
    struct tcp_pcb *pcb;

    for (pcb = pcbs; pcb < tailof(pcbs); pcb++) {
        if (pcb->state == TCP_PCB_STATE_FREE) {
            pcb->state = TCP_PCB_STATE_CLOSED;
            sched_ctx_init(&pcb->ctx);
            return pcb;
        }
    }
    return NULL;
}

static void
tcp_pcb_release(struct tcp_pcb *pcb)
{
    char ep1[IP_ENDPOINT_STR_LEN];
    char ep2[IP_ENDPOINT_STR_LEN];

    if (sched_ctx_destroy(&pcb->ctx) == -1) {
        sched_wakeup(&pcb->ctx);
        return;
    }
    debugf("released, local=%s, foreign=%s",
        ip_endpoint_ntop(&pcb->local, ep1, sizeof(ep1)),
        ip_endpoint_ntop(&pcb->foreign, ep2, sizeof(ep2)));
    memset(pcb, 0, sizeof(*pcb)); /* pcb->state is set to TCP_PCB_STATE_FREE (0) */
}

static struct tcp_pcb *
tcp_pcb_select(struct ip_endpoint *local, struct ip_endpoint *foreign)
{
    struct tcp_pcb *pcb, *listen_pcb = NULL;

    for (pcb = pcbs; pcb < tailof(pcbs); pcb++) {
        if ((pcb->local.addr == IP_ADDR_ANY || pcb->local.addr == local->addr) && pcb->local.port == local->port) {
            if (!foreign) {
                return pcb;
            }
            if (pcb->foreign.addr == foreign->addr && pcb->foreign.port == foreign->port) {
                return pcb;
            }
            if (pcb->state == TCP_PCB_STATE_LISTEN) {
                if (pcb->foreign.addr == IP_ADDR_ANY && pcb->foreign.port == 0) {
                    /* LISTENed with wildcard foreign address/port */
                    listen_pcb = pcb;
                }
            }
        }
    }
    return listen_pcb;
}

static struct tcp_pcb *
tcp_pcb_get(int id)
{
    struct tcp_pcb *pcb;

    if (id < 0 || id >= (int)countof(pcbs)) {
        /* out of range */
        return NULL;
    }
    pcb = &pcbs[id];
    if (pcb->state == TCP_PCB_STATE_FREE) {
        return NULL;
    }
    return pcb;
}

static int
tcp_pcb_id(struct tcp_pcb *pcb)
{
    return indexof(pcbs, pcb);
}

static ssize_t
tcp_output_segment(uint32_t seq, uint32_t ack, uint8_t flg, uint16_t wnd, uint8_t *data, size_t len, struct ip_endpoint *local, struct ip_endpoint *foreign)
{
    uint8_t *buf;
    struct tcp_hdr *hdr;
    struct pseudo_hdr pseudo;
    uint16_t psum;
    uint16_t total;
    char ep1[IP_ENDPOINT_STR_LEN];
    char ep2[IP_ENDPOINT_STR_LEN];

    buf = memory_alloc(IP_PAYLOAD_SIZE_MAX);
    if (!buf) {
        errorf("memory_alloc() failure");
        return -1;
    }
    hdr = (struct tcp_hdr *)buf;
    hdr->src = local->port;
    hdr->dst = foreign->port;
    hdr->seq = hton32(seq);
    hdr->ack = hton32(ack);
    hdr->off = (sizeof(*hdr) >> 2) << 4;
    hdr->flg = flg;
    hdr->wnd = hton16(wnd);
    hdr->sum = 0;
    hdr->up = 0;
    memcpy(hdr + 1, data, len);
    pseudo.src = local->addr;
    pseudo.dst = foreign->addr;
    pseudo.zero = 0;
    pseudo.protocol = IP_PROTOCOL_TCP;
    total = sizeof(*hdr) + len;
    pseudo.len = hton16(total);
    psum = ~cksum16((uint16_t *)&pseudo, sizeof(pseudo), 0);
    hdr->sum = cksum16((uint16_t *)hdr, total, psum);
    debugf("%s => %s, len=%zu (payload=%zu)",
        ip_endpoint_ntop(local, ep1, sizeof(ep1)),
        ip_endpoint_ntop(foreign, ep2, sizeof(ep2)),
        total, len);
    tcp_dump((uint8_t *)hdr, total);
    if (ip_output(IP_PROTOCOL_TCP, (uint8_t *)hdr, total, local->addr, foreign->addr) == -1) {
        memory_free(buf);
        return -1;
    }
    memory_free(buf);
    return len;
}

/*
 * TCP Retransmit
 *
 * NOTE: TCP Retransmit functions must be called after mutex locked
 */

static int
tcp_retransmit_queue_add(struct tcp_pcb *pcb, uint32_t seq, uint8_t flg, uint8_t *data, size_t len)
{
    struct tcp_queue_entry *entry;

    entry = memory_alloc(sizeof(*entry) + len);
    if (!entry) {
        errorf("memory_alloc() failure");
        return -1;
    }
    entry->rto = TCP_DEFAULT_RTO;
    entry->seq = seq;
    entry->flg = flg;
    entry->len = len;
    memcpy(entry->data, data, entry->len);
    gettimeofday(&entry->first, NULL);
    entry->last = entry->first;
    if (!queue_push(&pcb->queue, entry)) {
        errorf("queue_push() failure");
        memory_free(entry);
        return -1;
    }
    return 0;
}

static void
tcp_retransmit_queue_cleanup(struct tcp_pcb *pcb)
{
    struct tcp_queue_entry *entry;

    while (1) {
        entry = queue_peek(&pcb->queue);
        if (!entry) {
            break;
        }
        if (entry->seq >= pcb->snd.una) {
            break;
        }
        entry = queue_pop(&pcb->queue);
        debugf("remove, seq=%u, flags=%s, len=%u", entry->seq, tcp_flg_ntoa(entry->flg), entry->len);
        memory_free(entry);
    }
    return;
}

static void
tcp_retransmit_queue_emit(void *arg, void *data)
{
    struct tcp_pcb *pcb;
    struct tcp_queue_entry *entry;
    struct timeval now, diff, timeout;

    pcb = (struct tcp_pcb *)arg;
    entry = (struct tcp_queue_entry *)data;
    gettimeofday(&now, NULL);
    timersub(&now, &entry->first, &diff);
    if (diff.tv_sec >= TCP_RETRANSMIT_DEADLINE) {
        pcb->state = TCP_PCB_STATE_CLOSED;
        sched_wakeup(&pcb->ctx);
        return;
    }
    timeout = entry->last;
    timeval_add_usec(&timeout, entry->rto);
    if (timercmp(&now, &timeout, >)) {
        tcp_output_segment(entry->seq, pcb->rcv.nxt, entry->flg, pcb->rcv.wnd, entry->data, entry->len, &pcb->local, &pcb->foreign);
        entry->last = now;
        entry->rto *= 2;
    }
}

static ssize_t
tcp_output(struct tcp_pcb *pcb, uint8_t flg, uint8_t *data, size_t len)
{
    uint32_t seq;

    seq = pcb->snd.nxt;
    if (TCP_FLG_ISSET(flg, TCP_FLG_SYN)) {
        seq = pcb->iss;
    }
    if (TCP_FLG_ISSET(flg, TCP_FLG_SYN | TCP_FLG_FIN) || len) {
        tcp_retransmit_queue_add(pcb, seq, flg, data, len);
    }
    return tcp_output_segment(seq, pcb->rcv.nxt, flg, pcb->rcv.wnd, data, len, &pcb->local, &pcb->foreign);
}

/* rfc793 - section 3.9 [Event Processing > SEGMENT ARRIVES] */
static void
tcp_segment_arrives(struct tcp_segment_info *seg, uint8_t flags, uint8_t *data, size_t len, struct ip_endpoint *local, struct ip_endpoint *foreign)
{
    int acceptable = 0;
    struct tcp_pcb *pcb;

    pcb = tcp_pcb_select(local, foreign);
    if (!pcb || pcb->state == TCP_PCB_STATE_CLOSED) {
        if (TCP_FLG_ISSET(flags, TCP_FLG_RST)) {
            return;
        }
        if (!TCP_FLG_ISSET(flags, TCP_FLG_ACK)) {
            tcp_output_segment(0, seg->seq + seg->len, TCP_FLG_RST | TCP_FLG_ACK, 0, NULL, 0, local, foreign);
        } else {
            tcp_output_segment(seg->ack, 0, TCP_FLG_RST, 0, NULL, 0, local, foreign);
        }
        return;
    }
    switch(pcb->state) {
    case TCP_PCB_STATE_LISTEN:
        /*
         * 1st check for an RST
         */
        if (TCP_FLG_ISSET(flags, TCP_FLG_RST)) {
            return;
        }
        /*
         * 2nd check for an ACK
         */
        if (TCP_FLG_ISSET(flags, TCP_FLG_ACK)) {
            tcp_output_segment(seg->ack, 0, TCP_FLG_RST, 0, NULL, 0, local, foreign);
            return;
        }
        /*
         * 3rd check for an SYN
        */
        if (TCP_FLG_ISSET(flags, TCP_FLG_SYN)) {
            /* ignore: security/compartment check */
            /* ignore: precedence check */
            pcb->local = *local;
            pcb->foreign = *foreign;
            pcb->rcv.wnd = sizeof(pcb->buf);
            pcb->rcv.nxt = seg->seq + 1;
            pcb->irs = seg->seq;
            pcb->iss = random();
            tcp_output(pcb, TCP_FLG_SYN | TCP_FLG_ACK, NULL, 0);
            pcb->snd.nxt = pcb->iss + 1;
            pcb->snd.una = pcb->iss;
            pcb->state = TCP_PCB_STATE_SYN_RECEIVED;
            /* ignore: Note that any other incoming control or data             */
            /* (combined with SYN) will be processed in the SYN-RECEIVED state, */
            /* but processing of SYN and ACK  should not be repeated            */
            return;
        }
        /*
         * 4th other text or control
         */

        /* drop segment */
        return;
    case TCP_PCB_STATE_SYN_SENT:
        /*
         * 1st check the ACK bit
         */
        if (TCP_FLG_ISSET(flags, TCP_FLG_ACK)) {
            if (seg->ack <= pcb->iss || seg->ack > pcb->snd.nxt) {
                tcp_output_segment(seg->ack, 0, TCP_FLG_RST, 0, NULL, 0, local, foreign);
                return;
            }
            if (pcb->snd.una <= seg->ack && seg->ack <= pcb->snd.nxt) {
                acceptable = 1;
            }
        }
        /*
         * 2nd check the RST bit
         */

        /*
         * 3rd check security and precedence (ignore)
         */

        /*
         * 4th check the SYN bit
         */
        if (TCP_FLG_ISSET(flags, TCP_FLG_SYN)) {
            pcb->rcv.nxt = seg->seq + 1;
            pcb->irs = seg->seq;
            if (acceptable) {
                pcb->snd.una = seg->ack;
                tcp_retransmit_queue_cleanup(pcb);
            }
            if (pcb->snd.una > pcb->iss) {
                pcb->state = TCP_PCB_STATE_ESTABLISHED;
                tcp_output(pcb, TCP_FLG_ACK, NULL, 0);
                /* NOTE: not specified in the RFC793, but send window initialization required */
                pcb->snd.wnd = seg->wnd;
                pcb->snd.wl1 = seg->seq;
                pcb->snd.wl2 = seg->ack;
                sched_wakeup(&pcb->ctx);
                /* ignore: continue processing at the sixth step below where the URG bit is checked */
                return;
            } else {
                pcb->state = TCP_PCB_STATE_SYN_RECEIVED;
                tcp_output(pcb, TCP_FLG_SYN | TCP_FLG_ACK, NULL, 0);
                /* ignore: If there are other controls or text in the segment, queue them for processing after the ESTABLISHED state has been reached */
                return;
            }
        }
        /*
         * 5th, if neither of the SYN or RST bits is set then drop the segment and return
         */

        /* drop segment */
        return;
    }
    /*
     * Otherwise
     */

    /*
     * 1st check sequence number
     */
    switch (pcb->state) {
    case TCP_PCB_STATE_SYN_RECEIVED:
    case TCP_PCB_STATE_ESTABLISHED:
    case TCP_PCB_STATE_FIN_WAIT1:
    case TCP_PCB_STATE_FIN_WAIT2:
    case TCP_PCB_STATE_CLOSE_WAIT:
    case TCP_PCB_STATE_LAST_ACK:
        if (!seg->len) {
            if (!pcb->rcv.wnd) {
                if (seg->seq == pcb->rcv.nxt) {
                    acceptable = 1;
                }
            } else {
                if (pcb->rcv.nxt <= seg->seq && seg->seq < pcb->rcv.nxt + pcb->rcv.wnd) {
                    acceptable = 1;
                }
            }
        } else {
            if (!pcb->rcv.wnd) {
                /* not acceptable */
            } else {
                if ((pcb->rcv.nxt <= seg->seq && seg->seq < pcb->rcv.nxt + pcb->rcv.wnd) ||
                    (pcb->rcv.nxt <= seg->seq + seg->len - 1 && seg->seq + seg->len - 1 < pcb->rcv.nxt + pcb->rcv.wnd)) {
                    acceptable = 1;
                }
            }
        }
        if (!acceptable) {
            if (!TCP_FLG_ISSET(flags, TCP_FLG_RST)) {
                tcp_output(pcb, TCP_FLG_ACK, NULL, 0);
            }
            return;
        }
        /*
         * In the following it is assumed that the segment is the idealized
         * segment that begins at RCV.NXT and does not exceed the window.
         * One could tailor actual segments to fit this assumption by
         * trimming off any portions that lie outside the window (including
         * SYN and FIN), and only processing further if the segment then
         * begins at RCV.NXT.  Segments with higher begining sequence
         * numbers may be held for later processing.
         */
    }
    /*
     * 2nd check the RST bit
     */

    /*
     * 3rd check security and precedence (ignore)
     */

    /*
     * 4th check the SYN bit
     */

    /*
     * 5th check the ACK field
     */
    if (!TCP_FLG_ISSET(flags, TCP_FLG_ACK)) {
        /* drop segment */
        return;
    }
    switch (pcb->state) {
    case TCP_PCB_STATE_SYN_RECEIVED:
        if (pcb->snd.una <= seg->ack && seg->ack <= pcb->snd.nxt) {
            pcb->state = TCP_PCB_STATE_ESTABLISHED;
            sched_wakeup(&pcb->ctx);
        } else {
            tcp_output_segment(seg->ack, 0, TCP_FLG_RST, 0, NULL, 0, local, foreign);
            return;
        }
        /* fall through */
    case TCP_PCB_STATE_ESTABLISHED:
    case TCP_PCB_STATE_FIN_WAIT1:
    case TCP_PCB_STATE_FIN_WAIT2:
    case TCP_PCB_STATE_CLOSE_WAIT:
        if (pcb->snd.una < seg->ack && seg->ack <= pcb->snd.nxt) {
            pcb->snd.una = seg->ack;
            tcp_retransmit_queue_cleanup(pcb);
            /* ignore: Users should receive positive acknowledgments for buffers
                        which have been SENT and fully acknowledged (i.e., SEND buffer should be returned with "ok" response) */
            if (pcb->snd.wl1 < seg->seq || (pcb->snd.wl1 == seg->seq && pcb->snd.wl2 <= seg->ack)) {
                pcb->snd.wnd = seg->wnd;
                pcb->snd.wl1 = seg->seq;
                pcb->snd.wl2 = seg->ack;
            }
        } else if (seg->ack < pcb->snd.una) {
            /* ignore */
        } else if (seg->ack > pcb->snd.nxt) {
            tcp_output(pcb, TCP_FLG_ACK, NULL, 0);
            return;
        }
        switch (pcb->state) {
        case TCP_PCB_STATE_FIN_WAIT1:
            if (seg->ack == pcb->snd.nxt) {
                pcb->state = TCP_PCB_STATE_FIN_WAIT2;
            }
            break;
        case TCP_PCB_STATE_FIN_WAIT2:
            /* do not delete the TCB */
            break;
        case TCP_PCB_STATE_CLOSE_WAIT:
            /* do nothing */
            break;
        }
        break;
    case TCP_PCB_STATE_LAST_ACK:
        if (seg->ack == pcb->snd.nxt) {
            pcb->state = TCP_PCB_STATE_CLOSED;
            tcp_pcb_release(pcb);
        }
        return;
    }
    /*
     * 6th, check the URG bit (ignore)
     */

    /*
     * 7th, process the segment text
     */
    switch (pcb->state) {
    case TCP_PCB_STATE_ESTABLISHED:
    case TCP_PCB_STATE_FIN_WAIT1:
    case TCP_PCB_STATE_FIN_WAIT2:
        if (len) {
            memcpy(pcb->buf + (sizeof(pcb->buf) - pcb->rcv.wnd), data, len);
            pcb->rcv.nxt = seg->seq + seg->len;
            pcb->rcv.wnd -= len;
            tcp_output(pcb, TCP_FLG_ACK, NULL, 0);
            sched_wakeup(&pcb->ctx);
        }
        break;
    case TCP_PCB_STATE_CLOSE_WAIT:
    case TCP_PCB_STATE_LAST_ACK:
        /* ignore segment text */
        break;
    }
    /*
     * 8th, check the FIN bit
     */
    if (TCP_FLG_ISSET(flags, TCP_FLG_FIN)) {
        switch (pcb->state) {
        case TCP_PCB_STATE_CLOSED:
        case TCP_PCB_STATE_LISTEN:
            /* drop segment */
            return;
        }
        pcb->rcv.nxt = seg->seq + 1;
        tcp_output(pcb, TCP_FLG_ACK, NULL, 0);
        switch (pcb->state) {
        case TCP_PCB_STATE_SYN_RECEIVED:
        case TCP_PCB_STATE_ESTABLISHED:
            pcb->state = TCP_PCB_STATE_CLOSE_WAIT;
            sched_wakeup(&pcb->ctx);
            break;
        case TCP_PCB_STATE_FIN_WAIT1:
            if (seg->ack == pcb->snd.nxt) {
                pcb->state = TCP_PCB_STATE_TIME_WAIT;
                //tcp_set_timewait_timer(pcb);
            } else {
                pcb->state = TCP_PCB_STATE_CLOSING;
            }
            break;
        case TCP_PCB_STATE_FIN_WAIT2:
            pcb->state = TCP_PCB_STATE_TIME_WAIT;
            //tcp_set_timewait_timer(pcb);
            break;
        case TCP_PCB_STATE_CLOSE_WAIT:
            /* Remain in the CLOSE-WAIT state */
            break;
        case TCP_PCB_STATE_LAST_ACK:
            /* Remain in the LAST-ACK state */
            break;
        }
    }

    return;
}

static void
tcp_input(const uint8_t *data, size_t len, ip_addr_t src, ip_addr_t dst, struct ip_iface *iface)
{
    struct tcp_hdr *hdr;
    struct pseudo_hdr pseudo;
    uint16_t psum;
    char addr1[IP_ADDR_STR_LEN];
    char addr2[IP_ADDR_STR_LEN];
    struct ip_endpoint local, foreign;
    uint16_t hlen;
    struct tcp_segment_info seg;

    if (len < sizeof(*hdr)) {
        errorf("too short");
        return;
    }
    hdr = (struct tcp_hdr *)data;
    pseudo.src = src;
    pseudo.dst = dst;
    pseudo.zero = 0;
    pseudo.protocol = IP_PROTOCOL_TCP;
    pseudo.len = hton16(len);
    psum = ~cksum16((uint16_t *)&pseudo, sizeof(pseudo), 0);
    if (cksum16((uint16_t *)hdr, len, psum) != 0) {
        errorf("checksum error: sum=0x%04x, verify=0x%04x", ntoh16(hdr->sum), ntoh16(cksum16((uint16_t *)hdr, len, -hdr->sum + psum)));
        return;
    }
    if (src == IP_ADDR_BROADCAST || src == iface->broadcast || dst == IP_ADDR_BROADCAST || dst == iface->broadcast) {
        errorf("only supports unicast, src=%s, dst=%s",
            ip_addr_ntop(src, addr1, sizeof(addr1)), ip_addr_ntop(dst, addr2, sizeof(addr2)));
        return;
    }
    debugf("%s:%d => %s:%d, len=%zu (payload=%zu)",
        ip_addr_ntop(src, addr1, sizeof(addr1)), ntoh16(hdr->src),
        ip_addr_ntop(dst, addr2, sizeof(addr2)), ntoh16(hdr->dst),
        len, len - sizeof(*hdr));
    tcp_dump(data, len);
    local.addr = dst;
    local.port = hdr->dst;
    foreign.addr = src;
    foreign.port = hdr->src;
    hlen = (hdr->off >> 4) << 2;
    seg.seq = ntoh32(hdr->seq);
    seg.ack = ntoh32(hdr->ack);
    seg.len = len - hlen;
    if (TCP_FLG_ISSET(hdr->flg, TCP_FLG_SYN)) {
        seg.len++; /* SYN flag consumes one sequence number */
    }
    if (TCP_FLG_ISSET(hdr->flg, TCP_FLG_FIN)) {
        seg.len++; /* FIN flag consumes one sequence number */
    }
    seg.wnd = ntoh16(hdr->wnd);
    seg.up = ntoh16(hdr->up);
    mutex_lock(&mutex);
    tcp_segment_arrives(&seg, hdr->flg, (uint8_t *)hdr + hlen, len - hlen, &local, &foreign);
    mutex_unlock(&mutex);
    return;
}

static void
tcp_timer(void)
{
    struct tcp_pcb *pcb;

    mutex_lock(&mutex);
    for (pcb = pcbs; pcb < tailof(pcbs); pcb++) {
        if (pcb->state == TCP_PCB_STATE_FREE) {
            continue;
        }
        queue_foreach(&pcb->queue, tcp_retransmit_queue_emit, pcb);
    }
    mutex_unlock(&mutex);

}

static void
event_handler(void *arg)
{
    struct tcp_pcb *pcb;

    mutex_lock(&mutex);
    for (pcb = pcbs; pcb < tailof(pcbs); pcb++) {
        if (pcb->state != TCP_PCB_STATE_FREE) {
            sched_interrupt(&pcb->ctx);
        }
    }
    mutex_unlock(&mutex);
}

int
tcp_init(void)
{
    struct timeval interval = {0,100000}; /* 100ms */

    if (ip_protocol_register(IP_PROTOCOL_TCP, tcp_input) == -1) {
        errorf("ip_protocol_register() failure");
        return -1;
    }
    if (net_timer_register(interval, tcp_timer) == -1) {
        errorf("net_timer_register() failure");
        return -1;
    }
    net_event_subscribe(event_handler, NULL);
    return 0;
}

/*
 * TCP User Command (RFC793)
 */

int
tcp_open_rfc793(struct ip_endpoint *local, struct ip_endpoint *foreign, int active)
{
    struct tcp_pcb *pcb;
    char ep1[IP_ENDPOINT_STR_LEN];
    char ep2[IP_ENDPOINT_STR_LEN];
    int state, id;

    mutex_lock(&mutex);
    pcb = tcp_pcb_alloc();
    if (!pcb) {
        errorf("tcp_pcb_alloc() failure");
        mutex_unlock(&mutex);
        return -1;
    }
    if (active) {
        debugf("active open: local=%s, foreign=%s, connecting...",
            ip_endpoint_ntop(local, ep1, sizeof(ep1)), ip_endpoint_ntop(foreign, ep2, sizeof(ep2)));
        pcb->local = *local;
        pcb->foreign = *foreign;
        pcb->rcv.wnd = sizeof(pcb->buf);
        pcb->iss = random();
        if (tcp_output(pcb, TCP_FLG_SYN, NULL, 0) == -1) {
            errorf("tcp_output() failure");
            pcb->state = TCP_PCB_STATE_CLOSED;
            tcp_pcb_release(pcb);
            mutex_unlock(&mutex);
            return -1;
        }
        pcb->snd.una = pcb->iss;
        pcb->snd.nxt = pcb->iss + 1;
        pcb->state = TCP_PCB_STATE_SYN_SENT;
    } else {
        debugf("passive open: local=%s, waiting for connection...", ip_endpoint_ntop(local, ep1, sizeof(ep1)));
        pcb->local = *local;
        if (foreign) {
            pcb->foreign = *foreign;
        }
        pcb->state = TCP_PCB_STATE_LISTEN;
    }
AGAIN:
    state = pcb->state;
    /* waiting for state changed */
    while (pcb->state == state) {
        if (sched_sleep(&pcb->ctx, &mutex, NULL) == -1) {
            debugf("interrupted");
            pcb->state = TCP_PCB_STATE_CLOSED;
            tcp_pcb_release(pcb);
            mutex_unlock(&mutex);
            errno = EINTR;
            return -1;
        }
    }
    if (pcb->state != TCP_PCB_STATE_ESTABLISHED) {
        if (pcb->state == TCP_PCB_STATE_SYN_RECEIVED) {
            goto AGAIN;
        }
        errorf("open error: %d", pcb->state);
        pcb->state = TCP_PCB_STATE_CLOSED;
        tcp_pcb_release(pcb);
        mutex_unlock(&mutex);
        return -1;
    }
    id = tcp_pcb_id(pcb);
    debugf("connection established: local=%s, foreign=%s",
        ip_endpoint_ntop(&pcb->local, ep1, sizeof(ep1)), ip_endpoint_ntop(&pcb->foreign, ep2, sizeof(ep2)));
    mutex_unlock(&mutex);
    return id;
}

int
tcp_close(int id)
{
    struct tcp_pcb *pcb;

    mutex_lock(&mutex);
    pcb = tcp_pcb_get(id);
    if (!pcb) {
        errorf("pcb not found");
        mutex_unlock(&mutex);
        return -1;
    }
    switch (pcb->state) {
    case TCP_PCB_STATE_ESTABLISHED:
        tcp_output(pcb, TCP_FLG_ACK | TCP_FLG_FIN,  NULL, 0);
        pcb->snd.nxt++;
        pcb->state = TCP_PCB_STATE_FIN_WAIT1;
        break;
    case TCP_PCB_STATE_CLOSE_WAIT:
        tcp_output(pcb, TCP_FLG_ACK | TCP_FLG_FIN, NULL, 0);
        pcb->snd.nxt++;
        pcb->state = TCP_PCB_STATE_LAST_ACK; /* RFC793 says "enter CLOSING state", but it seems to be LAST-ACK state */
        break;
    default:
        errorf("unknown state '%u'", pcb->state);
        mutex_unlock(&mutex);
        return -1;
    }
    if (pcb->state == TCP_PCB_STATE_CLOSED) {
        tcp_pcb_release(pcb);
    } else {
        sched_wakeup(&pcb->ctx);
    }
    mutex_unlock(&mutex);
    return 0;

}

ssize_t
tcp_send(int id, uint8_t *data, size_t len)
{
    struct tcp_pcb *pcb;
    ssize_t sent = 0;
    struct ip_iface *iface;
    size_t mss, cap, slen;

    mutex_lock(&mutex);
    pcb = tcp_pcb_get(id);
    if (!pcb) {
        errorf("pcb not found");
        mutex_unlock(&mutex);
        return -1;
    }
RETRY:
   switch (pcb->state) {
    case TCP_PCB_STATE_ESTABLISHED:
    case TCP_PCB_STATE_CLOSE_WAIT:
        iface = ip_route_get_iface(pcb->foreign.addr);
        if (!iface) {
            errorf("iface not found");
            mutex_unlock(&mutex);
            return -1;
        }
        mss = NET_IFACE(iface)->dev->mtu - (IP_HDR_SIZE_MIN + sizeof(struct tcp_hdr));
        while (sent < (ssize_t)len) {
            cap = pcb->snd.wnd - (pcb->snd.nxt - pcb->snd.una);
            if (!cap) {
                if (sched_sleep(&pcb->ctx, &mutex, NULL) == -1) {
                    debugf("interrupted");
                    if (!sent) {
                        mutex_unlock(&mutex);
                        errno = EINTR;
                        return -1;
                    }
                    break;
                }
                goto RETRY;
            }
            slen = MIN(MIN(mss, len - sent), cap);
            if (tcp_output(pcb, TCP_FLG_ACK | TCP_FLG_PSH, data + sent, slen) == -1) {
                errorf("tcp_output() failure");
                pcb->state = TCP_PCB_STATE_CLOSED;
                tcp_pcb_release(pcb);
                mutex_unlock(&mutex);
                return -1;
            }
            pcb->snd.nxt += slen;
            sent += slen;
        }
        break;
    case TCP_PCB_STATE_LAST_ACK:
        errorf("connection closing");
        mutex_unlock(&mutex);
        return -1;
    default:
        errorf("unknown state '%u'", pcb->state);
        mutex_unlock(&mutex);
        return -1;
    }
    mutex_unlock(&mutex);
    return sent;
}

ssize_t
tcp_receive(int id, uint8_t *buf, size_t size)
{
    struct tcp_pcb *pcb;
    size_t remain, len;

    mutex_lock(&mutex);
    pcb = tcp_pcb_get(id);
    if (!pcb) {
        errorf("pcb not found");
        mutex_unlock(&mutex);
        return -1;
    }
RETRY:
    switch (pcb->state) {
    case TCP_PCB_STATE_ESTABLISHED:
        remain = sizeof(pcb->buf) - pcb->rcv.wnd;
        if (!remain) {
            if (sched_sleep(&pcb->ctx, &mutex, NULL) == -1) {
                debugf("interrupted");
                mutex_unlock(&mutex);
                errno = EINTR;
                return -1;
            }
            goto RETRY;
        }
        break;
    case TCP_PCB_STATE_CLOSE_WAIT:
        remain = sizeof(pcb->buf) - pcb->rcv.wnd;
        if (remain) {
            break;
        }
        debugf("connection closing");
        mutex_unlock(&mutex);
        return 0;
    default:
        errorf("unknown state '%u'", pcb->state);
        mutex_unlock(&mutex);
        return -1;
    }
    len = MIN(size, remain);
    memcpy(buf, pcb->buf, len);
    memmove(pcb->buf, pcb->buf + len, remain - len);
    pcb->rcv.wnd += len;
    mutex_unlock(&mutex);
    return len;
}
```
</details>

#### ✅ 初期化関数の呼び出し

`net_init()`からTCPモジュールの初期化関数を呼び出すようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/net.c</span></summary>

```diff
...

 #include "arp.h"
 #include "ip.h"
 #include "icmp.h"
 #include "udp.h"
+#include "tcp.h"

 int
 net_init(void)
 {
     if (intr_init() == -1) {
         errorf("intr_init() failure");
         return -1;
     }
     if (arp_init() == -1) {
         errorf("arp_init() failure");
         return -1;
     }
     if (ip_init() == -1) {
         errorf("ip_init() failure");
         return -1;
     }
     if (icmp_init() == -1) {
         errorf("icmp_init() failure");
         return -1;
     }
     if (udp_init() == -1) {
         errorf("udp_init() failure");
         return -1;
     }
+    if (tcp_init() == -1) {
+        errorf("tcp_init() failure");
+        return -1;
+    }
     infof("initialized");
     return 0;
 }
```
</details>

#### ✅ Makefileの修正

ソースファイルを追加したのでMakefileを追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
...
 	net/platform/xv6/std.o\
 	net/platform/xv6/driver/e1000.o\
 	net/util.o\
 	net/net.o\
 	net/ether.o\
 	net/arp.o\
 	net/ip.o\
 	net/icmp.o\
 	net/udp.o\
+	tcp/udp.o\
```
</details>

#### ✅ 動作確認

再ビルドした後、`make qemu-nox`を実行してxv6を起動します。

プロトコル番号`6`のプロトコル（TCP）がIPモジュールに登録されていることが確認できます。合わせてタイマも登録されていますが、タイマを実装していないためこちらは機能しません。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">起動ログ</span></summary>

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
10:53:11.000 [I] net_protocol_register: registered, type=0x0806 (net/net.c:176)
10:53:11.000 [I] net_timer_register: registered: interval={1, 0} (net/net.c:196)
10:53:11.000 [I] net_protocol_register: registered, type=0x0800 (net/net.c:176)
10:53:11.000 [I] ip_protocol_register: registered, type=1 (net/ip.c:303)
10:53:11.000 [I] ip_protocol_register: registered, type=17 (net/ip.c:303)
10:53:11.000 [I] ip_protocol_register: registered, type=6 (net/ip.c:303)
10:53:11.000 [I] net_timer_register: registered: interval={0, 100000} (net/net.c:196)
10:53:11.000 [I] net_init: initialized (net/net.c:367)
PCI: 00:00.0: 8086:1237: class: 6.0 (Bridge device) irq: 0
PCI: 00:01.0: 8086:7000: class: 6.1 (Bridge device) irq: 0
PCI: 00:01.1: 8086:7010: class: 1.1 (Storage controller) irq: 0
PCI: 00:01.3: 8086:7113: class: 6.80 (Bridge device) irq: 9
PCI: 00:02.0: 1234:1111: class: 3.0 (Display controller) irq: 0
PCI: 00:03.0: 8086:100e: class: 2.0 (Network controller) irq: 11
PCI function 00:03.0 (8086:100e) enabled
10:53:11.000 [I] net_device_register: registered, dev=net0, type=0x0002 (net/net.c:63)
10:53:11.000 [I] e1000init: initialized, irq=11, addr=52:54:00:12:34:56 (net/platform/xv6/driver/e1000.c:302)
10:53:11.000 [I] ip_route_add: route added: network=192.0.2.0, netmask=255.255.255.0, nexthop=0.0.0.0, iface=192.0.2.2 dev=net0 (net/ip.c:165)
10:53:11.000 [I] ip_iface_register: registered: dev=net0, unicast=192.0.2.2, netmask=255.255.255.0, broadcast=192.0.2.255 (net/ip.c:262)
10:53:11.000 [D] net_run: open all devices... (net/net.c:313)
10:53:11.000 [I] net_device_open: dev=net0, state=up (net/net.c:81)
10:53:11.000 [D] net_run: running... (net/net.c:317)
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
```
</details>

開発環境で別のシェルを開き、`192.0.2.2`の`7`番ポートを宛先にして`nc`コマンドを実行します。`-v`オプションを指定しておくと接続状況が把握しやすくなります。

```
$ nc -v 192.0.2.2 7
nc: connect to 192.0.2.2 port 7 (tcp) failed: Connection refused
```

`nc`コマンドを実行すると"Connection refused"のメッセージを出力して終了してしまいます。xv6側のログを確認すると、TCPモジュールに接続要求の`SYN`セグメントが届いた後、強制切断の`RST`セグメントを送信してます。使用していないポートへの接続のため、これが正しい動作です。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">動作ログ</span></summary>

```
10:53:19.000 [D] e1000intr: >>> (net/platform/xv6/driver/e1000.c:231)
10:53:19.000 [D] ether_input_helper: dev=net0, type=0x0806, len=60 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: ff:ff:ff:ff:ff:ff
       type: 0x0806
10:53:19.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0806, len=46 (net/net.c:238)
10:53:19.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0806, len=46 (net/net.c:260)
10:53:19.000 [D] arp_input: dev=net0, len=46 (net/arp.c:236)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 1 (Request)
        sha: 16:2a:af:19:b5:91
        spa: 192.0.2.1
        tha: 00:00:00:00:00:00
        tpa: 192.0.2.2
10:53:19.000 [D] arp_cache_insert: INSERT: pa=192.0.2.1, ha=16:2a:af:19:b5:91 (net/arp.c:173)
10:53:19.000 [D] arp_reply: dev=net0, len=28 (net/arp.c:210)
        hrd: 0x0001
        pro: 0x0800
        hln: 6
        pln: 4
         op: 2 (Reply)
        sha: 52:54:00:12:34:56
        spa: 192.0.2.2
        tha: 16:2a:af:19:b5:91
        tpa: 192.0.2.1
10:53:19.000 [D] net_device_output: dev=net0, type=0x0806, len=28 (net/net.c:146)
10:53:19.000 [D] ether_transmit_helper: dev=net0, type=0x0806, len=60 (net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0806
10:53:19.000 [D] e1000_write: dev=net0, 60 bytes data transmit (net/platform/xv6/driver/e1000.c:187)
10:53:19.000 [D] ether_input_helper: dev=net0, type=0x0800, len=74 (net/ether.c:123)
        src: 16:2a:af:19:b5:91
        dst: 52:54:00:12:34:56
       type: 0x0800
10:53:19.000 [D] net_input_handler: queue pushed (num:1), dev=net0, type=0x0800, len=60 (net/net.c:238)
10:53:19.000 [D] net_softirq_handler: queue popped (num:0), dev=net0, type=0x0800, len=60 (net/net.c:260)
10:53:19.000 [D] ip_input: dev=net0, iface=192.0.2.2, protocol=6, total=60 (net/ip.c:357)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 60 (payload: 40)
         id: 47371
     offset: 0x4000 [flags=2, offset=0]
        ttl: 64
   protocol: 6
        sum: 0xfdac
        src: 192.0.2.1
        dst: 192.0.2.2
10:53:19.000 [D] tcp_input: 192.0.2.1:52470 => 192.0.2.2:7, len=40 (payload=20) (net/tcp.c:695)
        src: 52470
        dst: 7
        seq: 2214156047
        ack: 0
        off: 0xa0 (40)
        flg: 0x02 (------S-)
        wnd: 64240
        sum: 0xeaa1
         up: 0
10:53:19.000 [D] tcp_output_segment: 192.0.2.2:7 => 192.0.2.1:52470, len=20 (payload=0) (net/tcp.c:257)
        src: 7
        dst: 52470
        seq: 0
        ack: 2214156048
        off: 0x50 (20)
        flg: 0x14 (---A-R--)
        wnd: 0
        sum: 0x83c5
         up: 0
10:53:19.000 [D] ip_output_core: dev=net0, dst=192.0.2.1, protocol=6, len=40 (net/ip.c:416)
        vhl: 0x45 [v: 4, hl: 5 (20)]
        tos: 0x00
      total: 40 (payload: 20)
         id: 128
     offset: 0x0000 [flags=0, offset=0]
        ttl: 255
   protocol: 6
        sum: 0x374c
        src: 192.0.2.2
        dst: 192.0.2.1
10:53:19.000 [D] arp_resolve: resolved, pa=192.0.2.1, ha=16:2a:af:19:b5:91 (net/arp.c:298)
10:53:19.000 [D] net_device_output: dev=net0, type=0x0800, len=40 (net/net.c:146)
10:53:19.000 [D] ether_transmit_helper: dev=net0, type=0x0800, len=60 (net/ether.c:88)
        src: 52:54:00:12:34:56
        dst: 16:2a:af:19:b5:91
       type: 0x0800
10:53:19.000 [D] e1000_write: dev=net0, 60 bytes data transmit (net/platform/xv6/driver/e1000.c:187)
10:53:19.000 [D] e1000intr: <<< (net/platform/xv6/driver/e1000.c:250)
```
</details>