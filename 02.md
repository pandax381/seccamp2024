# 2. 下準備

## 2.1. 型定義の追加

ビット幅指定の数値型などの型定義を追加しておきます。xv6では型定義を`types.h`に集約しているので、このファイルに追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">types.h</span></summary>

```diff
 typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+
+#ifndef BUILD_MKFS
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+typedef char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef long long int64_t;
+typedef unsigned long long uint64_t;
+
+typedef int32_t intptr_t;
+typedef uint32_t uintptr_t;
+
+typedef int32_t ssize_t;
+typedef uint32_t size_t;
+
+typedef __builtin_va_list va_list;
+
+#endif
```
</details>

xv6を起動する`make qemu-nox`を実行した際に、コマンドの実行ファイルなどを格納したディスクイメージ（`fs.img`）を作製するプログラム（`mkfs`）がコンパイルおよび実行されます。この`mkfs`は、xv6ではなくホストで実行するプログラムであるため、コンパイル時にはホスト環境のヘッダファイルが読み込まれます。ホスト環境のヘッダファイルが読み込まれると、ここで追加している型定義との衝突が発生してしまうため、`mkfs`のコンパイル時のみ`BUILD_MKFS`を定義して追加の型定義が読み込まれないようにします。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
...

 mkfs: mkfs.c fs.h
-	gcc -Werror -Wall -o mkfs mkfs.c
+	gcc -Werror -Wall -DBUILD_MKFS -o mkfs mkfs.c

...
```
</details>

## 2.2. コンソール出力の改良

### 2.2.1. コンソール出力

xv6のカーネル内からコンソールへ文字列を出力するには`cprintf()`を使用します。

```c
cprintf("Hello, world!\n");
```

標準ライブラリの`printf()`とよく似ていますが、フォーマット文字列のサポートが限定的です。

- サポートしている変換指定子は `%d`、`%x`、`%p`、`%s` のみ
- フラグ文字やフィールド幅、精度、長さ修飾子などもサポートしていない

`cprintf()`のコードは`console.c`に含まれています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">console.c</span></summary>

```c
// Print to the console. only understands %d, %x, %p, %s.
void
cprintf(char *fmt, ...)
{
  int i, c, locking;
  uint *argp;
  char *s;

  locking = cons.locking;
  if(locking)
    acquire(&cons.lock);

  if (fmt == 0)
    panic("null fmt");

  argp = (uint*)(void*)(&fmt + 1);
  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
    if(c != '%'){
      consputc(c);
      continue;
    }
    c = fmt[++i] & 0xff;
    if(c == 0)
      break;
    switch(c){
    case 'd':
      printint(*argp++, 10, 1);
      break;
    case 'x':
    case 'p':
      printint(*argp++, 16, 0);
      break;
    case 's':
      if((s = (char*)*argp++) == 0)
        s = "(null)";
      for(; *s; s++)
        consputc(*s);
      break;
    case '%':
      consputc('%');
      break;
    default:
      // Print unknown % sequence to draw attention.
      consputc('%');
      consputc(c);
      break;
    }
  }

  if(locking)
    release(&cons.lock);
}
```
</details>

### 2.2.2. 改良版のコンソール出力

xv6のコンソール出力は簡素すぎるため、より多くのフォーマット文字列をサポートする実装に差し替えます。今回は「JOS」という、xv6と同じくMITの6.828コースで利用されている教育用のOSからコードを拝借します。

+ Lab1 - MIT 6.828 (2018): https://pdos.csail.mit.edu/6.828/2018/labs/lab1/
+ Gitリポジトリ: https://pdos.csail.mit.edu/6.828/2018/jos.git


上記のGitリポジトリから抽出した2つのファイルを、xv6の作業ディレクトリへ追加します。

> NOTE: 下記のコードをそのままコピー＆ペーストしてください。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">printfmt.c</span></summary>

```c
// Stripped-down primitive printf-style formatting routines,
// used in common by printf, sprintf, fprintf, etc.
// This code is also used by both the kernel and user programs.

#include "types.h"
#include "defs.h"
#include "error.h"

/*
 * Space or zero padding and a field width are supported for the numeric
 * formats only.
 *
 * The special format %e takes an integer error code
 * and prints a string describing the error.
 * The integer may be positive or negative,
 * so that -E_NO_MEM and E_NO_MEM are equivalent.
 */

static const char * const error_string[MAXERROR] =
{
  [E_UNSPECIFIED] = "unspecified error",
  [E_BAD_ENV] = "bad environment",
  [E_INVAL] = "invalid parameter",
  [E_NO_MEM]  = "out of memory",
  [E_NO_FREE_ENV] = "out of environments",
  [E_FAULT] = "segmentation fault",
  [E_IPC_NOT_RECV]= "env is not recving",
  [E_EOF]   = "unexpected end of file",
  [E_NO_DISK] = "no free space on disk",
  [E_MAX_OPEN]  = "too many files are open",
  [E_NOT_FOUND] = "file or block not found",
  [E_BAD_PATH]  = "invalid path",
  [E_FILE_EXISTS] = "file already exists",
  [E_NOT_EXEC]  = "file is not a valid executable",
  [E_NOT_SUPP]  = "operation not supported",
};

/*
 * Print a number (base <= 16) in reverse order,
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
   unsigned long long num, unsigned base, int width, int padc)
{
  // first recursively print all preceding (more significant) digits
  if (num >= base) {
    printnum(putch, putdat, num / base, base, width - 1, padc);
  } else {
    // print any needed pad characters before first digit
    while (--width > 0)
      putch(padc, putdat);
  }

  // then print this (the least significant) digit
  putch("0123456789abcdef"[num % base], putdat);
}

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  if (lflag >= 2)
    return va_arg(*ap, unsigned long long);
  else if (lflag)
    return va_arg(*ap, unsigned long);
  else
    return va_arg(*ap, unsigned int);
}

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  if (lflag >= 2)
    return va_arg(*ap, long long);
  else if (lflag)
    return va_arg(*ap, long);
  else
    return va_arg(*ap, int);
}


// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  register const char *p;
  register int ch, err;
  unsigned long long num;
  int base, lflag, width, precision, altflag;
  char padc;

  while (1) {
    while ((ch = *(unsigned char *) fmt++) != '%') {
      if (ch == '\0')
        return;
      putch(ch, putdat);
    }

    // Process a %-escape sequence
    padc = ' ';
    width = -1;
    precision = -1;
    lflag = 0;
    altflag = 0;
  reswitch:
    switch (ch = *(unsigned char *) fmt++) {

    // flag to pad on the right
    case '-':
      padc = '-';
      goto reswitch;

    // flag to pad with 0's instead of spaces
    case '0':
      padc = '0';
      goto reswitch;

    // width field
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      for (precision = 0; ; ++fmt) {
        precision = precision * 10 + ch - '0';
        ch = *fmt;
        if (ch < '0' || ch > '9')
          break;
      }
      goto process_precision;

    case '*':
      precision = va_arg(ap, int);
      goto process_precision;

    case '.':
      if (width < 0)
        width = 0;
      goto reswitch;

    case '#':
      altflag = 1;
      goto reswitch;

    process_precision:
      if (width < 0)
        width = precision, precision = -1;
      goto reswitch;

    // long flag (doubled for long long)
    case 'l':
      lflag++;
      goto reswitch;

    // character
    case 'c':
      putch(va_arg(ap, int), putdat);
      break;

    // error message
    case 'e':
      err = va_arg(ap, int);
      if (err < 0)
        err = -err;
      if (err >= MAXERROR || (p = error_string[err]) == NULL)
        printfmt(putch, putdat, "error %d", err);
      else
        printfmt(putch, putdat, "%s", p);
      break;

    // string
    case 's':
      if ((p = va_arg(ap, char *)) == NULL)
        p = "(null)";
      if (width > 0 && padc != '-')
        for (width -= strnlen(p, precision); width > 0; width--)
          putch(padc, putdat);
      for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
        if (altflag && (ch < ' ' || ch > '~'))
          putch('?', putdat);
        else
          putch(ch, putdat);
      for (; width > 0; width--)
        putch(' ', putdat);
      break;

    // (signed) decimal
    case 'd':
      num = getint(&ap, lflag);
      if ((long long) num < 0) {
        putch('-', putdat);
        num = -(long long) num;
      }
      base = 10;
      goto number;

    // unsigned decimal
    case 'u':
      num = getuint(&ap, lflag);
      base = 10;
      goto number;

    // (unsigned) octal
    case 'o':
      // Replace this with your code.
      putch('X', putdat);
      putch('X', putdat);
      putch('X', putdat);
      break;

    // pointer
    case 'p':
      putch('0', putdat);
      putch('x', putdat);
      num = (unsigned long long)
        (uintptr_t) va_arg(ap, void *);
      base = 16;
      goto number;

    // (unsigned) hexadecimal
    case 'x':
      num = getuint(&ap, lflag);
      base = 16;
    number:
      printnum(putch, putdat, num, base, width, padc);
      break;

    // escaped '%' character
    case '%':
      putch(ch, putdat);
      break;

    // unrecognized escape sequence - just print it literally
    default:
      putch('%', putdat);
      for (fmt--; fmt[-1] != '%'; fmt--)
        /* do nothing */;
      break;
    }
  }
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  vprintfmt(putch, putdat, fmt, ap);
  va_end(ap);
}

struct sprintbuf {
  char *buf;
  char *ebuf;
  int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  b->cnt++;
  if (b->buf < b->ebuf)
    *b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  struct sprintbuf b = {buf, buf+n-1, 0};

  if (buf == NULL || n < 1)
    return -E_INVAL;

  // print the string to the buffer
  vprintfmt((void*)sprintputch, &b, fmt, ap);

  // null terminate the buffer
  *b.buf = '\0';

  return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  va_list ap;
  int rc;

  va_start(ap, fmt);
  rc = vsnprintf(buf, n, fmt, ap);
  va_end(ap);

  return rc;
}
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">error.h</span></summary>

```c
/* See COPYRIGHT for copyright information. */

#ifndef JOS_INC_ERROR_H
#define JOS_INC_ERROR_H

enum {
	// Kernel error codes -- keep in sync with list in lib/printfmt.c.
	E_UNSPECIFIED	= 1,	// Unspecified or unknown problem
	E_BAD_ENV	,	// Environment doesn't exist or otherwise
				// cannot be used in requested action
	E_INVAL		,	// Invalid parameter
	E_NO_MEM	,	// Request failed due to memory shortage
	E_NO_FREE_ENV	,	// Attempt to create a new environment beyond
				// the maximum allowed
	E_FAULT		,	// Memory fault

	E_IPC_NOT_RECV	,	// Attempt to send to env that is not recving
	E_EOF		,	// Unexpected end of file

	// File system error codes -- only seen in user-level
	E_NO_DISK	,	// No free space left on disk
	E_MAX_OPEN	,	// Too many files are open
	E_NOT_FOUND	, 	// File or block not found
	E_BAD_PATH	,	// Bad path
	E_FILE_EXISTS	,	// File already exists
	E_NOT_EXEC	,	// File not a valid executable
	E_NOT_SUPP	,	// Operation not supported

	MAXERROR
};

#endif	// !JOS_INC_ERROR_H */
```

</details>

#### ✅ 不足している標準ライブラリ関数の追加

上記の`printfmt.c`に含まれる`vprintfmt()`は`strnlen()`を必要としますが、この関数はxv6には含まれていません。文字列関連をまとめている`string.c`へ`strnlen()`を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">string.c</span></summary>

```diff
...

+int
+strnlen(const char *s, uint z)
+{
+  int n;
+
+  for (n = 0; z > 0 && s[n]; n++, z--)
+    ;
+  return n;
+}
```
</details>

`strnlen()`は終端文字が含まれない可能性のある文字列の長さを計測する関数です。引数で指定した最大バイト数に達しても終端文字が現れなかった場合にはそこで計測を打ち切ります。

#### ✅ プロトタイプ宣言の追加

ソースファイル外に公開する関数のプロトタイプ宣言を追加します。xv6では関数のプロトタイプ宣言を`defs.h`に集約しているので、このファイルに追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">defs.h</span></summary>

```diff
...

 // pipe.c
 int             pipealloc(struct file**, struct file**);
 void            pipeclose(struct pipe*, int);
 int             piperead(struct pipe*, char*, int);
 int             pipewrite(struct pipe*, char*, int);

+// printfmt.c
+void            vprintfmt(void (*)(int, void*), void*, const char*, va_list);
+void            printfmt(void (*)(int, void*), void*, const char*, ...);
+int             vsnprintf(char*, int, const char*, va_list);
+int             snprintf(char*, int, const char*, ...);
+
...

 // string.c
 int             memcmp(const void*, const void*, uint);
 void*           memmove(void*, const void*, uint);
 void*           memset(void*, int, uint);
 char*           safestrcpy(char*, const char*, int);
 int             strlen(const char*);
+int             strnlen(const char*, uint);
 int             strncmp(const char*, const char*, uint);
 char*           strncpy(char*, const char*, int);

...

 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+
+// variable length arguments
+#define va_start(ap, last) __builtin_va_start(ap, last)
+#define va_arg(ap, type) __builtin_va_arg(ap, type)
+#define va_end(ap) __builtin_va_end(ap)
```
</details>

可変長引数を扱うための関数についてはGCCのビルトイン機能を利用するので、そのための定義も追加しています。

#### ✅ Makefileの修正

ビルド用の`Makefile`を修正します。GCCのビルトイン機能を使用するために`libgcc`をリンクするようにしています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
 	bio.o\
 	console.o\
 	exec.o\
 	file.o\
 	fs.o\
 	ide.o\
 	ioapic.o\
 	kalloc.o\
 	kbd.o\
 	lapic.o\
 	log.o\
 	main.o\
 	mp.o\
 	picirq.o\
 	pipe.o\
+	printfmt.o\
 	proc.o\
 	sleeplock.o\
 	spinlock.o\
 	string.o\
 	swtch.o\
 	syscall.o\
 	sysfile.o\
 	sysproc.o\
 	trapasm.o\
 	trap.o\
 	uart.o\
 	vectors.o\
 	vm.o\

...

+GCC_LIB := $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)
+
 xv6.img: bootblock kernel
 	dd if=/dev/zero of=xv6.img count=10000
 	dd if=bootblock of=xv6.img conv=notrunc
 	dd if=kernel of=xv6.img seek=1 conv=notrunc

...

 kernel: $(OBJS) entry.o entryother initcode kernel.ld
-	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) $(GCC_LIB) -b binary initcode entryother
 	$(OBJDUMP) -S kernel > kernel.asm
 	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym

...
```
</details>

一旦、この状態で追加ファイルを含めてビルドが通るか確認しておきます。

```
$ make clean
$ make
```

#### ✅ コンソール出力関数の差し替え

コンソール出力関数（`cprintf`）を差し替える準備ができたので、`console.c`を次のように変更します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">console.c</span></summary>

```diff
...

-static void
-printint(int xx, int base, int sign)
-{
-  static char digits[] = "0123456789abcdef";
-  char buf[16];
-  int i;
-  uint x;
-
-  if(sign && (sign = xx < 0))
-    x = -xx;
-  else
-    x = xx;
-
-  i = 0;
-  do{
-    buf[i++] = digits[x % base];
-  }while((x /= base) != 0);
-
-  if(sign)
-    buf[i++] = '-';
-
-  while(--i >= 0)
-    consputc(buf[i]);
-}
-//PAGEBREAK: 50
-
-// Print to the console. only understands %d, %x, %p, %s.
-void
-cprintf(char *fmt, ...)
-{
-  int i, c, locking;
-  uint *argp;
-  char *s;
-
-  locking = cons.locking;
-  if(locking)
-    acquire(&cons.lock);
-
-  if (fmt == 0)
-    panic("null fmt");
-
-  argp = (uint*)(void*)(&fmt + 1);
-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
-    if(c != '%'){
-      consputc(c);
-      continue;
-    }
-    c = fmt[++i] & 0xff;
-    if(c == 0)
-      break;
-    switch(c){
-    case 'd':
-      printint(*argp++, 10, 1);
-      break;
-    case 'x':
-    case 'p':
-      printint(*argp++, 16, 0);
-      break;
-    case 's':
-      if((s = (char*)*argp++) == 0)
-        s = "(null)";
-      for(; *s; s++)
-        consputc(*s);
-      break;
-    case '%':
-      consputc('%');
-      break;
-    default:
-      // Print unknown % sequence to draw attention.
-      consputc('%');
-      consputc(c);
-      break;
-    }
-  }
-
-  if(locking)
-    release(&cons.lock);
-}
+static void
+putch(int ch, int *cnt)
+{
+  consputc(ch);
+  (void)*cnt++;
+}
+
+int
+vcprintf(const char *fmt, va_list ap)
+{
+  int cnt = 0;
+
+  vprintfmt((void*)putch, &cnt, fmt, ap);
+  return cnt;
+}
+
+int
+cprintf(const char *fmt, ...)
+{
+  int locking, cnt;
+  va_list ap;
+
+  locking = cons.locking;
+  if(locking)
+    acquire(&cons.lock);
+
+  va_start(ap, fmt);
+  cnt = vcprintf(fmt, ap);
+  va_end(ap);
+
+  if(locking)
+    release(&cons.lock);
+
+  return cnt;
+}

...
```
</details>

既存の`cprintf()`と付随する`printint()`は使用しないので削除してしまいます。新しい`cprintf()`は戻り値が`int`に変更になるため、合わせてプロトタイプ宣言も変更します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">defs.h</span></summary>

```diff
...

 // console.c
 void            consoleinit(void);
+int             vcprintf(const char*, va_list);
-void            cprintf(char*, ...);
+int             cprintf(const char*, ...);
 void            consoleintr(int(*)(void));
 void            panic(char*) __attribute__((noreturn));

...
```
</details>

## 2.3. 現在時刻の取得

### 2.3.1. RTCの利用

xv6には、RTC（Real Time Clock）から現在時刻を取得する`cmostime()`が用意されています。なお、`cmostime()`に対応するシステムコールは（システムコール追加の演習のために）わざと実装されていないため、カーネル内でのみ使用可能です。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">lapic.c</span></summary>

```c
...

#define CMOS_PORT    0x70
#define CMOS_RETURN  0x71

...

#define CMOS_STATA   0x0a
#define CMOS_STATB   0x0b
#define CMOS_UIP    (1 << 7)        // RTC update in progress

#define SECS    0x00
#define MINS    0x02
#define HOURS   0x04
#define DAY     0x07
#define MONTH   0x08
#define YEAR    0x09

static uint
cmos_read(uint reg)
{
  outb(CMOS_PORT,  reg);
  microdelay(200);

  return inb(CMOS_RETURN);
}

static void
fill_rtcdate(struct rtcdate *r)
{
  r->second = cmos_read(SECS);
  r->minute = cmos_read(MINS);
  r->hour   = cmos_read(HOURS);
  r->day    = cmos_read(DAY);
  r->month  = cmos_read(MONTH);
  r->year   = cmos_read(YEAR);
}

// qemu seems to use 24-hour GWT and the values are BCD encoded
void
cmostime(struct rtcdate *r)
{
  struct rtcdate t1, t2;
  int sb, bcd;

  sb = cmos_read(CMOS_STATB);

  bcd = (sb & (1 << 2)) == 0;

  // make sure CMOS doesn't modify time while we read it
  for(;;) {
    fill_rtcdate(&t1);
    if(cmos_read(CMOS_STATA) & CMOS_UIP)
        continue;
    fill_rtcdate(&t2);
    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
      break;
  }

  // convert
  if(bcd) {
#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
    CONV(second);
    CONV(minute);
    CONV(hour  );
    CONV(day   );
    CONV(month );
    CONV(year  );
#undef     CONV
  }

  *r = t1;
  r->year += 2000;
}
```
</details>

RTCから時刻情報を読み出すには、`CMOS_PORT`と`CMOS_RETURN`の2つのI/Oポートを次のように操作します。

 1. `CMOS_PORT`に対してレジスタ番号を書き込む
 2. `CMOS_RETURN`から1で指定したレジスタの値を読み出す


`CMOS_STATA`と`CMOS_STATB`はどちらもステータスレジスタで、次のような情報が含まれています。

```
		0A    status register A
		       bit 7 = 1  update in progress
		       bit 6-4 divider that identifies the time-based frequency
		       bit 3-0 rate selection output  frequency and int. rate
		0B    status register B
		       bit 7 = 0  run
		             = 1  halt
		       bit 6 = 1  enable periodic interrupt
		       bit 5 = 1  enable alarm interrupt
		       bit 4 = 1  enable update-ended interrupt
		       bit 3 = 1  enable square wave interrupt
		       bit 2 = 1  calendar is in binary format
		             = 0  calendar is in BCD format
		       bit 1 = 1  24-hour mode
		             = 0  12-hour mode
		       bit 0 = 1  enable daylight savings time. only in USA.
		                  useless in Europe. Some DOS versions clear
		                  this bit when you use the DAT/TIME command.
```

時刻情報は複数のレジスタに分散しているため更新中に読み出すと正しい値を取得できません。ステータスレジスタAにて更新中であることを検知したら読み出しをやりなおします。更に、時刻情報を2回読み出して値が一致した場合に読み込み成功とみなしています。また、ステータスレジスタBにてBCDエンコードされていることが示されていたらデコードして本来の値を求めます。

> BCD（Binary-Coded Decimal）では、10進数の1桁（0-9）を2進数4桁（16進数1桁）で表します。例えば、10進数の「31」をBCDでは「0011 0001（0x31）」と表現します。((bcd >> 4) * 10) + (bcd & 0xf) で本来の10進数が得られます。

時刻情報を扱うための構造体（`struct rtcdate`）は`date.h`に定義されています。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">date.h</span></summary>

```c
struct rtcdate {
  uint second;
  uint minute;
  uint hour;
  uint day;
  uint month;
  uint year;
};
```
</details>

`struct tm`とフィールド構成が似ていますが、曜日や年初からの経過日数などのフィールドがありません。

#### ✅ 動作確認

xv6の起動時に、RTCから現在時刻を取得してコンソールへ出力するコードを追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">main.c</span></summary>

```diff
 #include "types.h"
 #include "defs.h"
 #include "param.h"
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
 #include "x86.h"
+#include "date.h"

...

 int
 main(void)
 {
   kinit1(end, P2V(4*1024*1024)); // phys page allocator
   kvmalloc();      // kernel page table
   mpinit();        // detect other processors
   lapicinit();     // interrupt controller
   seginit();       // segment descriptors
   picinit();       // disable pic
   ioapicinit();    // another interrupt controller
   consoleinit();   // console hardware
   uartinit();      // serial port
   pinit();         // process table
   tvinit();        // trap vectors
   binit();         // buffer cache
   fileinit();      // file table
   ideinit();       // disk 
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
+  struct rtcdate rd;
+  cmostime(&rd);
+  cprintf("%04d/%02d/%02d %02d:%02d:%02d\n",
+    rd.year, rd.month, rd.day, rd.hour, rd.minute, rd.second);
   mpmain();        // finish this processor's setup
 }

...
```
</details>

再ビルドした後、`make qemu-nox`を実行してxv6を起動させます。

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
2024/08/02 15:07:21
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$ 
```

起動時に現在時刻が出力されるようになったはずです。

### 2.3.2. UNIXタイムへの変換

プログラムから時刻の比較や演算を行うには`struct rtcdate`のような構造体よりもUNIXタイムの方が扱いやすいため、`struct rtcdate`をUNIXタイムへ変換する関数（およびその逆の動作をする関数）を作ります。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">time.c</span></summary>

```c
#include "types.h"
#include "defs.h"
#include "date.h"

static int
isleapyear(int y)
{
    return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);
}

static int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

static int
ndays(int y, int m)
{
    int n = days[m];

    if (m == 2 && isleapyear(y)) {
        n++;
    }
    return n;
}

long
rtcdate2unixtime(struct rtcdate *r)
{
    const int epoch = 1970;
    int y, m;
    long unixtime = 0;

    for (y = epoch; y < r->year; y++) {
        unixtime += (isleapyear(y) ? 366 : 365) * 24 * 3600;
    }
    for (m = 1; m < r->month; m++) {
        unixtime += ndays(r->year, m) * 24 * 3600;
    }
    unixtime += (r->day - 1) * 24 * 3600;
    unixtime += r->hour * 3600;
    unixtime += r->minute * 60;
    unixtime += r->second;
    return unixtime;
}

struct rtcdate *
unixtime2rtcdate(long unixtime, struct rtcdate *r)
{   
    r->second = unixtime % 60;
    unixtime /= 60;
    r->minute = unixtime % 60;
    unixtime /= 60;
    r->hour = unixtime % 24;
    unixtime /= 24;
    
    int days = unixtime;
    
    int y = 1970;
    while (1) { 
        int n = isleapyear(y) ? 366 : 365;
        if (days < n) {
            break;
        }
        days -= n;
        y++;
    }
    r->year = y;
    
    int m = 1;
    while (1) { 
        int n = ndays(y, m);
        if (days < n) {
            break;
        }
        days -= n;
        m++;
    }
    r->month = m; 
    r->day = days + 1;
    return r;
}
```
</details>

UNIXタイムはUNIXエポック（`1970/01/01 00:00:00`）からの経過秒です。閏年は考慮しますが閏秒は無視します。

#### ✅ プロトタイプ宣言の追加

追加した関数のプロトタイプ宣言を`defs.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">defs.h</span></summary>

```diff
...

 // syscall.c
 int             argint(int, int*);
 int             argptr(int, char**, int);
 int             argstr(int, char**);
 int             fetchint(uint, int*);
 int             fetchstr(uint, char**);
 void            syscall(void);

+// time.c
+long            rtcdate2unixtime(struct rtcdate*);
+struct rtcdate* unixtime2rtcdate(long, struct rtcdate*);

 // timer.c
 void            timerinit(void);

...
```
</details>

#### ✅ Makefileの修正

新しくソースファイルを追加したので、オブジェクトファイルのリスト（`OBJS`）に定義を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
...
 	sysproc.o\
+	time.o\
 	trapasm.o\
 	trap.o\
 	uart.o\
 	vectors.o\
 	vm.o\

...
```
</details>

#### ✅ 動作確認

`struct rtcdate`からUNIXタイムに変換した値をコンソールに出力するコードを追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">main.c</span></summary>

```diff
...

 int
 main(void)
 {
...
   userinit();      // first user process
   struct rtcdate rd;
+  long unixtime;
   cmostime(&rd);
   cprintf("%04d/%02d/%02d %02d:%02d:%02d\n",
     rd.year, rd.month, rd.day, rd.hour, rd.minute, rd.second);
+  unixtime = rtcdate2unixtime(&rd);
+  cprintf("unixtime: %d\n", unixtime);
+  unixtime2rtcdate(unixtime, &rd);
+  cprintf("%04d/%02d/%02d %02d:%02d:%02d\n",
+    rd.year, rd.month, rd.day, rd.hour, rd.minute, rd.second);
   mpmain();        // finish this processor's setup
 }

...
```
</details>

再ビルドした後、`make qemu-nox`を実行してxv6を起動させます。

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
2024/08/09 18:08:26
unixtime: 1723226906
2024/08/09 18:08:26
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
```

カレンダー形式の時刻に続けてUNIXタイムが出力されるようになったはずです。なお、`date`コマンドを利用するとUNIXタイムを任意の書式に変換の時刻できます。これを利用して出力されているUNIXタイムが正しい値かどうか検証できます。開発環境のシェルで次のコマンドを実行してください。

```
$ date -d @1723226906 +"%Y/%m/%d %T"
```

`struct rtcdate`の内容を`cprintf()`で出力したのと同じ結果が得られたら正しくUNIXタイムに変換できています。

### 2.3.3. 時刻関連の関数の追加

#### ✅ 時刻を扱う型の追加

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">types.h</span></summary>

```diff
...

 #ifndef BUILD_MKFS

...

 typedef __builtin_va_list va_list;

+typedef long time_t;

 #endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">date.h</span></summary>

```diff
 struct rtcdate {
   uint second;
   uint minute;
   uint hour;
   uint day;
   uint month;
   uint year;
 };

+struct timeval {
+  long tv_sec;
+  long tv_usec;
+};
```
</details>

#### ✅ 現在時刻を得る関数の追加

現在時刻を得る関数、具体的には`time()`と`gettimeofday()`の2つの関数を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">time.c</span></summary>

```diff
...

 long
 rtcdate2unixtime(struct rtcdate *r)
 {
...
 }

+time_t
+time(time_t *t)
+{
+  struct rtcdate r;
+  time_t _t;
+
+  cmostime(&r);
+  if (!t)
+    t = &_t;
+  *t = (time_t)rtcdate2unixtime(&r);
+  return *t;
+}
+
+int
+gettimeofday(struct timeval *tv, void *tz)
+{
+  (void)tz;
+  tv->tv_sec = time(NULL);
+  tv->tv_usec = 0;
+  return 0;
+}
```
</details>

#### ✅ プロトタイプ宣言の追加

追加した関数のプロトタイプ宣言を`defs.h`に追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">defs.h</span></summary>

```diff
 struct buf;
 struct context;
 struct file;
 struct inode;
 struct pipe;
 struct proc;
 struct rtcdate;
 struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct timeval;

...

 // time.c
 long            rtcdate2unixtime(struct rtcdate *);
+time_t          time(time_t*);
+int             gettimeofday(struct timeval*, void*);

...
```
</details>

#### ✅ 動作確認

`gettimeofday()`を呼び出すコードを追加します。`gettimeofday()`は内部で`time()`を呼び出すようにしているため、追加した2つの関数のが両方とも呼び出されます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">main.c</span></summary>

```diff
...

 int
 main(void)
 {
...
   userinit();      // first user process
   struct rtcdate rd;
   long unixtime;
+  struct timeval tv;
   cmostime(&rd);
   cprintf("%04d/%02d/%02d %02d:%02d:%02d\n",
     rd.year, rd.month, rd.day, rd.hour, rd.minute, rd.second);
   unixtime = rtcdate2unixtime(&rd);
   cprintf("unixtime: %d\n", unixtime);
   unixtime2rtcdate(unixtime, &rd);
   cprintf("%04d/%02d/%02d %02d:%02d:%02d\n",
     rd.year, rd.month, rd.day, rd.hour, rd.minute, rd.second);
+  gettimeofday(&tv, NULL);
+  cprintf("tv: {sec: %d, usec: %d}\n", tv.tv_sec, tv.tv_usec);
   mpmain();        // finish this processor's setup
 }

...
```
</details>

再ビルドした後、`make qemu-nox`を実行してxv6を起動させます。

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
2024/08/11 02:03:41
unixtime: 1723341821
2024/08/11 02:03:41
tv: {sec: 1723341821, usec: 0}
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
```

`tv: {sec: xxx, usec: xxx}` が`struct timeval`の内容を出力したものです。`sec`が先に出力しているUNIXタイムの値と一致していれば正しく動作しています。`usec`は常に`0`になるはずです。

## 2.4. 便利ライブラリの移植

自作プロトコルスタックの実装をサポートするための便利ライブラリ（`util.c`、`util.h`）を先に移植しておきます。

#### ✅ ディレクトリの作成

xv6のコードはフラットに配置されていますが、プロトコルスタックのコードは`net`ディレクトリを作成してその中に配置します。プラットフォーム依存のコードを配置するためのディレクトリまで一括で作成します。

```
$ mkdir -p net/platform/xv6
```

ヘッダファイルを正しく検出できるように、`net`ディレクトリと`net/platform/xv6`ディレクトリをインクルードパスに追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
...

 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -I . -I net -I net/platform/xv6
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)

...

 clean: 
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	net/*.o net/*.d net/platform/xv6/*.o net/platform/xv6/*.d \
 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
 	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
 	xv6memfs.img mkfs .gdbinit \
 	$(UPROGS)

...
```
</details>

#### ✅ プラットフォーム依存コードの追加

まず、プラットフォーム依存のコードを追加します。いまの時点ではメモリ関連のコードだけ含めています。その他は必要になったタイミングで随時追加していきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/platform.h</span></summary>

```c
#ifndef PLATFORM_H
#define PLATFORM_H

#include "types.h"
#include "defs.h"

/*
 * Memory
 */

#include "mmu.h"

static inline void *
memory_alloc(size_t size)
{
    void *p;

    if (PGSIZE < size) {
        return NULL;
    }
    p = kalloc();
    if (p) {
        memset(p, 0, size);
    }
    return p;
}

static inline void
memory_free(void *ptr)
{
    kfree(ptr);
}

/*
 * Mutex
 */

#include "param.h"
#include "spinlock.h"
#include "proc.h"



/*
 * Interrupt
 */

#include "traps.h"



/*
 * Scheduler
 */



#endif
```
</details>

xv6のカーネル内ではメモリは`kalloc()`で確保します。確保するメモリのサイズは指定できず、常にページサイズ（4KB）のメモリが返されます。自作プロトコルスタックでは4KBを超えるメモリを確保することはないので問題ないはずです。`kalloc()`で確保したメモリは`kfree()`で解放します。

#### ✅ 便利ライブラリの配置

便利ライブラリのファイルを`net`ディレクトリの下に配置します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/util.c</span></summary>

```c
#include "platform.h"

#include "util.h"

/*
 * Logging
 */

int
lprintf(FILE *fp, int level, const char *file, int line, const char *func, const char *fmt, ...)
{
    struct timeval tv;
    struct tm tm;
    char timestamp[32];
    int n = 0;
    va_list ap;

    flockfile(fp);
    gettimeofday(&tv, NULL);
    strftime(timestamp, sizeof(timestamp), "%T", localtime_r(&tv.tv_sec, &tm));
    n += fprintf(fp, "%s.%03d [%c] %s: ", timestamp, (int)(tv.tv_usec / 1000), level, func);
    va_start(ap, fmt);
    n += vfprintf(fp, fmt, ap);
    va_end(ap);
    n += fprintf(fp, " (%s:%d)\n", file, line);
    funlockfile(fp);
    return n;
}

void
hexdump(FILE *fp, const void *data, size_t size)
{
    unsigned char *src;
    int offset, index;

    flockfile(fp);
    src = (unsigned char *)data;
    fprintf(fp, "+------+-------------------------------------------------+------------------+\n");
    for(offset = 0; offset < (int)size; offset += 16) {
        fprintf(fp, "| %04x | ", offset);
        for(index = 0; index < 16; index++) {
            if(offset + index < (int)size) {
                fprintf(fp, "%02x ", 0xff & src[offset + index]);
            } else {
                fprintf(fp, "   ");
            }
        }
        fprintf(fp, "| ");
        for(index = 0; index < 16; index++) {
            if(offset + index < (int)size) {
                if(isascii(src[offset + index]) && isprint(src[offset + index])) {
                    fprintf(fp, "%c", src[offset + index]);
                } else {
                    fprintf(fp, ".");
                }
            } else {
                fprintf(fp, " ");
            }
        }
        fprintf(fp, " |\n");
    }
    fprintf(fp, "+------+-------------------------------------------------+------------------+\n");
    funlockfile(fp);
}

/*
 * Queue
 */

struct queue_entry {
    struct queue_entry *next;
    void *data;
};

void
queue_init(struct queue_head *queue)
{
    queue->head = NULL;
    queue->tail = NULL;
    queue->num = 0;
}

void *
queue_push(struct queue_head *queue, void *data)
{
    struct queue_entry *entry;

    if (!queue) {
        return NULL;
    }
    entry = memory_alloc(sizeof(*entry));
    if (!entry) {
        return NULL;
    }
    entry->next = NULL;
    entry->data = data;
    if (queue->tail) {
        queue->tail->next = entry;
    }
    queue->tail = entry;
    if (!queue->head) {
        queue->head = entry;
    }
    queue->num++;
    return data;
}

void *
queue_pop(struct queue_head *queue)
{
    struct queue_entry *entry;
    void *data;

    if (!queue || !queue->head) {
        return NULL;
    }
    entry = queue->head;
    queue->head = entry->next;
    if (!queue->head) {
        queue->tail = NULL;
    }
    queue->num--;
    data = entry->data;
    memory_free(entry);
    return data;
}

void *
queue_peek(struct queue_head *queue)
{
    if (!queue || !queue->head) {
        return NULL;
    }
    return queue->head->data;
}

void
queue_foreach(struct queue_head *queue, void (*func)(void *arg, void *data), void *arg)
{
    struct queue_entry *entry;

    if (!queue || !func) {
        return;
    }
    for (entry = queue->head; entry; entry = entry->next) {
        func(arg, entry->data);
    }
}

/*
 * Byteorder
 */

#ifndef __BIG_ENDIAN
#define __BIG_ENDIAN 4321
#endif
#ifndef __LITTLE_ENDIAN
#define __LITTLE_ENDIAN 1234
#endif

static int endian;

static int
byteorder(void) {
    uint32_t x = 0x00000001;

    return *(uint8_t *)&x ? __LITTLE_ENDIAN : __BIG_ENDIAN;
}

static uint16_t
byteswap16(uint16_t v)
{
    return (v & 0x00ff) << 8 | (v & 0xff00 ) >> 8;
}

static uint32_t
byteswap32(uint32_t v)
{
    return (v & 0x000000ff) << 24 | (v & 0x0000ff00) << 8 | (v & 0x00ff0000) >> 8 | (v & 0xff000000) >> 24;
}

uint16_t
hton16(uint16_t h)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap16(h) : h;
}

uint16_t
ntoh16(uint16_t n)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap16(n) : n;
}

uint32_t
hton32(uint32_t h)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap32(h) : h;
}

uint32_t
ntoh32(uint32_t n)
{
    if (!endian) {
        endian = byteorder();
    }
    return endian == __LITTLE_ENDIAN ? byteswap32(n) : n;
}

/*
 * Checksum
 */

uint16_t
cksum16(uint16_t *addr, uint16_t count, uint32_t init)
{
    uint32_t sum;

    sum = init;
    while (count > 1) {
        sum += *(addr++);
        count -= 2;
    }
    if (count > 0) {
        sum += *(uint8_t *)addr;
    }
    while (sum >> 16) {
        sum = (sum & 0xffff) + (sum >> 16);
    }
    return ~(uint16_t)sum;
}
```
</details>


<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/util.h</span></summary>

```c
#ifndef UTIL_H
#define UTIL_H

#include "platform.h"

/*
 * Compare
 */

#ifndef MAX
#define MAX(x, y) ((x) > (y) ? (x) : (y))
#endif
#ifndef MIN
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

/*
 * Array
 */

#define countof(x) ((sizeof(x) / sizeof(*x)))
#define tailof(x) (x + countof(x))
#define indexof(x, y) (((uintptr_t)y - (uintptr_t)x) / sizeof(*y))

/*
 * Time
 */

#define timeval_add_usec(x, y)         \
    do {                               \
        (x)->tv_sec += y / 1000000;    \
        (x)->tv_usec += y % 1000000;   \
        if ((x)->tv_usec >= 1000000) { \
            (x)->tv_sec += 1;          \
            (x)->tv_usec -= 1000000;   \
        }                              \
    } while(0);

#define timespec_add_nsec(x, y)           \
    do {                                  \
        (x)->tv_sec += y / 1000000000;    \
        (x)->tv_nsec += y % 1000000000;   \
        if ((x)->tv_nsec >= 1000000000) { \
            (x)->tv_sec += 1;             \
            (x)->tv_nsec -= 1000000000;   \
        }                                 \
    } while(0);

/*
 * Logging
 */

#define errorf(...) lprintf(stderr, 'E', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define warnf(...) lprintf(stderr, 'W', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define infof(...) lprintf(stderr, 'I', __FILE__, __LINE__, __func__, __VA_ARGS__)
#define debugf(...) lprintf(stderr, 'D', __FILE__, __LINE__, __func__, __VA_ARGS__)

#ifdef HEXDUMP
#define debugdump(...) hexdump(stderr, __VA_ARGS__)
#else
#define debugdump(...)
#endif

extern int
lprintf(FILE *fp, int level, const char *file, int line, const char *func, const char *fmt, ...);
extern void
hexdump(FILE *fp, const void *data, size_t size);

/*
 * Queue
 */

struct queue_entry;

struct queue_head {
    struct queue_entry *head;
    struct queue_entry *tail;
    unsigned int num;
};

extern void
queue_init(struct queue_head *queue);
extern void *
queue_push(struct queue_head *queue, void *data);
extern void *
queue_pop(struct queue_head *queue);
extern void *
queue_peek(struct queue_head *queue);
extern void
queue_foreach(struct queue_head *queue, void (*func)(void *arg, void *data), void *arg);

/*
 * Byteorder
 */

extern uint16_t
hton16(uint16_t h);
extern uint16_t
ntoh16(uint16_t n);
extern uint32_t
hton32(uint32_t h);
extern uint32_t
ntoh32(uint32_t n);

/*
 * Checksum
 */

extern uint16_t
cksum16(uint16_t *addr, uint16_t count, uint32_t init);

#endif
```
</details>

xv6のコンパイルでは`-nostdinc`が指定されるため、`#include <>`でシステムヘッダをインクルードしている箇所でエラーが発生してしまいます。これに対処するために、システムヘッダのインクルードを全て削除しています。この先で追加するプロトコルスタック関連のファイルについても、システムヘッダのインクルードを取り除き、替わりに`platform.h`を冒頭でインクルードするように変更します。

#### ✅ 不足している標準ライブラリ関数の追加

xv6には標準ライブラリが実装されていないため、必要な関数は自分で追加する必要があります。ここでは、便利ライブラリが必要とする関数に加えて自作プロトコルスタックの移植で必要になる関数を追加しておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/std.h</span></summary>

```c
#ifndef STD_H
#define STD_H

#include "date.h"

#define UINT16_MAX 65535

#define isascii(x) ((x >= 0x00) && (x <= 0x7f))
#define isprint(x) ((x >= 0x20) && (x <= 0x7e))

#define EINTR 1

extern int errno;

/*
 * STDIO
 */

typedef struct {
    /* dummy */
} FILE;

extern FILE *stderr;

#define fprintf(fp, ...) cprintf(__VA_ARGS__)
#define vfprintf(fp, ...) vcprintf(__VA_ARGS__)

extern void
flockfile(FILE *fp);
extern void
funlockfile(FILE *fp);
extern int
vfprintf(FILE *fp, const char *fmt, va_list ap);

/*
 * Time
 */

struct timespec {
    /* dummy */
};

struct tm {
    struct rtcdate r;
};

extern size_t
strftime(char *s, size_t max, const char *format, const struct tm *tm);
extern struct tm *
localtime_r(const time_t *timep, struct tm *result);
extern void
timersub(struct timeval *a, struct timeval *b, struct timeval *res);
extern void
timerclear(struct timeval *tv);

#define timercmp(a, b, cmp) \
    ((a)->tv_sec == (b)->tv_sec ? (a)->tv_usec cmp (b)->tv_usec : (a)->tv_sec cmp (b)->tv_sec)

/*
 * Random
 */

extern void
srand(unsigned int newseed);
extern long
random(void);

/*
 * String
 */

extern void *
memcpy(void *dst, const void *src, uint n);
extern long
strtol(const char *s, char **endptr, int base);
extern char *
strrchr(const char *cp, int ch);

#endif
```
</details>

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/std.c</span></summary>

```c
#include "platform.h"

/*
 * STDIO
 */

FILE *stderr;

void
flockfile(FILE *fp)
{
    /* dummy */
}

void
funlockfile(FILE *fp)
{
    /* dummy */
}

/*
 * Time
 */

size_t
strftime(char *s, size_t max, const char *format, const struct tm *tm)
{
    (void)format; /* force HH:MM:SS */
    return snprintf(s, max, "%02d:%02d:%02d", tm->r.hour, tm->r.minute, tm->r.second);
}

struct tm *
localtime_r(const time_t *timep, struct tm *result)
{
    /* ignore timezone */
    unixtime2rtcdate(*timep, &result->r);    
    return result;
}

void
timersub(struct timeval *a, struct timeval *b, struct timeval *res)
{   
    res->tv_sec = a->tv_sec - b->tv_sec;
    res->tv_usec = a->tv_usec - b->tv_usec;
    if (res->tv_usec < 0) {
        --res->tv_sec;
        res->tv_usec += 1000*1000;
    }
    return;
}

void
timerclear(struct timeval *tv)
{
    tv->tv_sec = 0;
    tv->tv_usec = 0;
}

/*
 * Random
 */

static unsigned int seed = 1;

void
srand(unsigned int newseed)
{
    seed = newseed;
}

long
random(void)
{
    /* Linear Congruential Generator (LCG) */
    seed = (seed * 1103515245 + 12345) % 0x7fffffff;
    return seed;
}

/*
 * String
 */

long
strtol(const char *s, char **endptr, int base)
{
    int neg = 0;
    long val = 0;

    // gobble initial whitespace
    while (*s == ' ' || *s == '\t')
        s++;

    // plus/minus sign
    if (*s == '+')
        s++;
    else if (*s == '-')
        s++, neg = 1;

    // hex or octal base prefix
    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
        s += 2, base = 16;
    else if (base == 0 && s[0] == '0')
        s++, base = 8;
    else if (base == 0)
        base = 10;

    // digits
    while (1) {
        int dig;

        if (*s >= '0' && *s <= '9')
            dig = *s - '0';
        else if (*s >= 'a' && *s <= 'z')
            dig = *s - 'a' + 10;
        else if (*s >= 'A' && *s <= 'Z')
            dig = *s - 'A' + 10;
        else
            break;
        if (dig >= base)
            break;
        s++, val = (val * base) + dig;
        // we don't properly detect overflow!
    }

    if (endptr)
        *endptr = (char *) s;
    return (neg ? -val : val);
}

char *
strrchr(const char *cp, int ch)
{
    char *save;
    char c;

    for (save = (char *) 0; (c = *cp); cp++) {
        if (c == ch) {
            save = (char *) cp;
        }
    }
    return save;
}
```
</details>

一部、ダミーの関数も含んでいますが主に下記のカテゴリの関数を追加しています。

+ 標準入出力
+ 時刻関連
+ ランダム関数
+ 文字列操作

`platform.h`をインクルードすれば`std.h`も自動的に読み込まれるようにしておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/platform/xv6/platform.h</span></summary>

```diff
 #ifndef PLATFORM_H
 #define PLATFORM_H

 #include "types.h"
 #include "defs.h"

+#include "std.h"
+
...
```
</details>

#### ✅ 動作確認

動作確認用に、自作プロトコルスタックのメインモジュールに相当するファイルを追加します（このファイルは後に削除します）。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">net/net.c</span></summary>

```c
#include "platform.h"

#include "util.h"

void
netinit(void)
{
    char msg[] = "Hello, SecCamp2024!";

    debugf("%s", msg);
    debugdump(msg, sizeof(msg));
}
```
</details>

便利ライブラリの機能を使ってログ出力と16進ダンプをテストします。`netinit()`はxv6の`main()`関数から呼び出すので、`defs.h`にプロトタイプ宣言を追加しておきます。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">defs.h</span></summary>

```diff
...

 // vm.c
 void            seginit(void);
 void            kvmalloc(void);
 pde_t*          setupkvm(void);
 char*           uva2ka(pde_t*, char*);
 int             allocuvm(pde_t*, uint, uint);
 int             deallocuvm(pde_t*, uint, uint);
 void            freevm(pde_t*);
 void            inituvm(pde_t*, char*, uint);
 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
 pde_t*          copyuvm(pde_t*, uint);
 void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);

+// net/net.c
+void            netinit(void);
+
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))

...
```
</details>

追加したソースファイルに関する定義を`Makefile`に追加します。また、`debugdump()`マクロを有効にするために`CFLAGS`に`-DHEXDUMP`を追加します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">Makefile</span></summary>

```diff
 OBJS = \
...
 	uart.o\
 	vectors.o\
 	vm.o\
+	net/platform/xv6/std.o\
+	net/util.o\
+	net/net.o\

...

 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -I . -I net -I net/platform/xv6
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -I . -I net -I net/platform/xv6 -DHEXDUMP
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)

...
```
</details>

xv6の`main()`関数から`netinit()`を呼び出すようにします。加えて、時刻のテストで追加したコードを削除します。

<details style="margin-left: 0.5em">
<summary><span style="color:#ffff00;font-style:italic;">main.c</span></summary>

```diff
 int
 main(void)
 {
...
   binit();         // buffer cache
   fileinit();      // file table
   ideinit();       // disk 
+  netinit();       // network stack
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
-  struct rtcdate rd;
-  long unixtime;
-  struct timeval tv;
-  cmostime(&rd);
-  cprintf("%04d/%02d/%02d %02d:%02d:%02d\n",
-    rd.year, rd.month, rd.day, rd.hour, rd.minute, rd.second);
-  unixtime = rtcdate2unixtime(&rd);
-  cprintf("unixtime: %d\n", unixtime);
-  unixtime2rtcdate(unixtime, &rd);
-  cprintf("%04d/%02d/%02d %02d:%02d:%02d\n",
-    rd.year, rd.month, rd.day, rd.hour, rd.minute, rd.second);
-  gettimeofday(&tv, NULL);
-  cprintf("tv: {sec: %d, usec: %d}\n", tv.tv_sec, tv.tv_usec);
   mpmain();        // finish this processor's setup
 }

```
</details>

再ビルドした後、`make qemu-nox`を実行してxv6を起動させます。

```
SeaBIOS (version 1.15.0-1)


iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+1FF8B4A0+1FECB4A0 CA00
                                                                               


Booting from Hard Disk..xv6...
05:00:47.000 [D] netinit: Hello, SecCamp2024! (net/net.c:10)
+------+-------------------------------------------------+------------------+
| 0000 | 48 65 6c 6c 6f 2c 20 53 65 63 43 61 6d 70 32 30 | Hello, SecCamp20 |
| 0010 | 32 34 21 00                                     | 24!.             |
+------+-------------------------------------------------+------------------+
cpu0: starting 0
sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58
init: starting sh
$
```

見覚えのある書式のログメッセージと16進ダンプが出力されるはずです。

これでプロトコルスタックを移植する準備が整いました。